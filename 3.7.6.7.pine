// @version=6
indicator(title='N', shorttitle='N', overlay=true, max_bars_back=4999, max_polylines_count=100, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// Import Professional Calculation Library
import PineCoders/ConditionalAverages/1 as pc

// =============================================================================
// ==== INPUTS ====
// =============================================================================

// Constants
var string FONT_MONO = font.family_monospace
var DEFAULT_LINE_STYLE = line.style_dotted
var PVWAP_LINE_STYLE = line.style_solid // Added new constant for pvwap and key level lines
var DEFAULT_LABEL_STYLE = label.style_label_left
var int KEYLEVEL_LINE_LENGTH = 3

// ==== Rolling VWAP Settings ====
group_rvwap = '滚动VWAP设置 (Rolling VWAP)'
show_7d = input.bool(true, '显示7天 (Show 7D)', group=group_rvwap)
show_30d = input.bool(true, '显示30天 (Show 30D)', group=group_rvwap)
show_90d = input.bool(true, '显示90天 (Show 90D)', group=group_rvwap)
show_365d = input.bool(true, '显示365天 (Show 365D)', group=group_rvwap)
color_7d = input.color(color.new(#81C784, 40), '7D颜色 (Color)', group=group_rvwap, inline='7d')
color_30d = input.color(color.new(#FF9800, 40), '30D颜色 (Color)', group=group_rvwap, inline='30d')
color_90d = input.color(color.new(#9C27B0, 40), '90D颜色 (Color)', group=group_rvwap, inline='90d')
color_365d = input.color(color.new(#BDBDBD, 40), '365D颜色 (Color)', group=group_rvwap, inline='365d')
rvwap_ref_tf = input.string('60', '参考时间框架 (Reference TF)', options=['5', '15', '60', '240', 'D'], group=group_rvwap, tooltip='用于计算滚动VWAP的参考时间框架')
rvwap_smoothing = input.int(1, '平滑周期 (Smoothing)', minval=1, maxval=100, group=group_rvwap, tooltip='滚动VWAP的平滑周期数')

// ==== Anchored VWAP Settings ====
VWAP_Ctl_Group = '锚定VWAP (Anchored VWAP)'
vwapSource = hlc3

// --- VWAP #1 (Defaults to Quarterly) ---
VWAP1_Settings = 'VWAP #1 Settings (Quarterly Default)'
VWAP1_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
Anchor1 = input.string(defval='Quarter', title='', group=VWAP_Ctl_Group, inline=VWAP1_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP1_Col = input.color(color.new(#FF4081, 80), title='POC', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
Bands1_Col = input.color(color.new(#FF4081, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
VWAP1_Bgc = input.color(color.new(#FF79B0, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP1_Settings)

// --- VWAP #2 (Defaults to Monthly) ---
VWAP2_Settings = 'VWAP #2 Settings (Monthly Default)'
VWAP2_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
Anchor2 = input.string(defval='Month', title='', group=VWAP_Ctl_Group, inline=VWAP2_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP2_Col = input.color(color.new(#00E676, 80), title='POC', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
Bands2_Col = input.color(color.new(#00E676, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
VWAP2_Bgc = input.color(color.new(#69F0AE, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP2_Settings)

// --- VWAP #3 (Defaults to Weekly) ---
VWAP3_Settings = 'VWAP #3 Settings (Weekly Default)'
VWAP3_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
Anchor3 = input.string(defval='Week', title='', group=VWAP_Ctl_Group, inline=VWAP3_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP3_Col = input.color(color.new(#29B6F6, 80), title='POC', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
Bands3_Col = input.color(color.new(#29B6F6, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
VWAP3_Bgc = input.color(color.new(#81D4FA, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP3_Settings)

// --- VWAP #4 (Defaults to Daily) ---
VWAP4_Settings = 'VWAP #4 Settings (Daily Default)'
VWAP4_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
Anchor4 = input.string(defval='Day', title='', group=VWAP_Ctl_Group, inline=VWAP4_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP4_Col = input.color(color.new(#FFFF00, 80), title='POC', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
Bands4_Col = input.color(color.new(#FFFF00, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
VWAP4_Bgc = input.color(color.new(#FFFF8D, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP4_Settings)

// --- VWAP #5 (Defaults to Yearly) ---
VWAP5_Settings = 'VWAP #5 Settings (Yearly Default)'
VWAP5_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
Anchor5 = input.string(defval='Year', title='', group=VWAP_Ctl_Group, inline=VWAP5_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP5_Col = input.color(color.new(#009688, 80), title='POC', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
Bands5_Col = input.color(color.new(#009688, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
VWAP5_Bgc = input.color(color.new(#80CBC4, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP5_Settings)

// ==== Previous Period VWAP Settings ====
VWAP_KeyLevel_Grp = '前期VWAP关键水平 (Previous VWAP Key Level)'
use_adaptive_tf = input.bool(true, '使用自适应时间框架 (Use Adaptive TF)', group=VWAP_KeyLevel_Grp, tooltip="根据当前图表时间框架自动选择合适的锚定时间框架进行计算")
use_tf_consistent_pvwap = input.bool(true, '使用跨时间框架pVWAP (TF-Consistent pVWAP)', group=VWAP_KeyLevel_Grp, tooltip="使用一致的计算方法在所有时间框架下显示一致的pVWAP值")
show_pvwap_yearly = input.bool(true, "显示前期年度VWAP (Show Previous Yearly VWAP)", group=VWAP_KeyLevel_Grp, inline="pyVWAP")
color_pvwap_yearly = input.color(color.new(#009688, 30), "", group=VWAP_KeyLevel_Grp, inline="pyVWAP")
show_pvwap_quarterly = input.bool(true, "显示前期季度VWAP (Show Previous Quarterly VWAP)", group=VWAP_KeyLevel_Grp, inline="pqVWAP")
color_pvwap_quarterly = input.color(color.new(#FF4081, 30), "", group=VWAP_KeyLevel_Grp, inline="pqVWAP")
show_pvwap_monthly = input.bool(true, "显示前期月度VWAP (Show Previous Monthly VWAP)", group=VWAP_KeyLevel_Grp, inline="pmVWAP")
color_pvwap_monthly = input.color(color.new(#00E676, 30), "", group=VWAP_KeyLevel_Grp, inline="pmVWAP")
show_pvwap_weekly = input.bool(true, "显示前期周度VWAP (Show Previous Weekly VWAP)", group=VWAP_KeyLevel_Grp, inline="pwVWAP")
color_pvwap_weekly = input.color(color.new(#29B6F6, 30), "", group=VWAP_KeyLevel_Grp, inline="pwVWAP")
label_color_setting = input.color(color.new(color.yellow, 100), 'pVWAP 标签背景 (Label BG)', group=VWAP_KeyLevel_Grp)
pvwap_offset = input.int(20, 'pVWAP 标签偏移 (Label Offset)', minval=1, group=VWAP_KeyLevel_Grp)
pvwap_format_level = input.string('#.####', 'pVWAP 价格格式 (Price Format)', group=VWAP_KeyLevel_Grp)

// ==== Key Open Level Settings ====
KeyOpen_Grp = '关键开盘价 (Key Open Levels)'
keylevel_offset = input.int(50, '开盘价 标签偏移 (Label Offset)', minval=1, group=KeyOpen_Grp, tooltip="Offset for Key Open labels, different from pVWAP offset.")
keylevel_format = input.string('#.####', '开盘价 价格格式 (Price Format)', group=KeyOpen_Grp)
use_ref_tf_for_opens = input.bool(true, '使用日线计算关键开盘价 (Use Daily for Key Opens)', group=KeyOpen_Grp, tooltip='开启后将使用日线数据来确保在所有时间框架下关键开盘价保持一致')
show_MonthlyOpen = input.bool(true, "月开盘价 (Monthly Open)", group=KeyOpen_Grp, inline="MO")
color_MonthlyOpen = input.color(color.new(#00E676, 30), "", group=KeyOpen_Grp, inline="MO")
show_YearlyOpen = input.bool(true, "年开盘价 (Yearly Open)", group=KeyOpen_Grp, inline="YO")
color_YearlyOpen = input.color(color.new(#009688, 30), "", group=KeyOpen_Grp, inline="YO")
show_WeeklyOpen = input.bool(true, "周开盘价 (Weekly Open)", group=KeyOpen_Grp, inline="WO")
color_WeeklyOpen = input.color(color.new(#29B6F6, 30), "", group=KeyOpen_Grp, inline="WO")
show_QuarterlyOpen = input.bool(true, "季开盘价 (Quarterly Open)", group=KeyOpen_Grp, inline="QO")
color_QuarterlyOpen = input.color(color.new(#FF4081, 30), "", group=KeyOpen_Grp, inline="QO")
show_DailyOpen = input.bool(true, "日开盘价 (Daily Open)", group=KeyOpen_Grp, inline="DO")
color_DailyOpen = input.color(color.new(#FFFF00, 30), "", group=KeyOpen_Grp, inline="DO")

// ==== Monday Range Settings ====
MondayRange_Grp = '周一区间 (Monday Range)'
show_MondayRange = input.bool(true, "显示周一区间 (Show Monday Range)", group=MondayRange_Grp)
color_PrevMonday = input.color(color.new(#757575, 30), "上周颜色 (Prev Week Color)", group=MondayRange_Grp, inline="MR1")
color_CurrMonday = input.color(color.new(#757575, 30), "本周颜色 (Curr Week Color)", group=MondayRange_Grp, inline="MR2")

// ==== Volume Profile Settings ====
group_vp = '成交量分布图 (Volume Profile)'
vp_enable = input.bool(true, '启用VP (Enable VP)', group = group_vp)
vp_show_profile = input.bool(true, '显示VP柱状图 (Show VP Histogram)', inline = 'VP_Display', tooltip = '是否显示成交量分布图的柱状图', group = group_vp)
vp_profile_color = input.color(color.new(#37474F, 25), '', inline = 'VP_Display', group = group_vp)
vp_show_historical = input.bool(true, '显示历史VP (Show Historical VP)', inline = 'VP_History', tooltip = '是否显示历史成交量分布图', group = group_vp)
vp_historical_color = input.color(color.new(#37474F, 25), '', inline = 'VP_History', group = group_vp)
// Value Area固定颜色设置为#78909C，不透明度25%
vp_value_area_color = color.new(#78909C, 25)
vp_max_history = input.int(3, '历史VP数量 (Max History)', 1, 10, tooltip = '最大保存的历史VP数量', group = group_vp)
vp_show_poc = input.bool(true, '显示VPOC (Show VPOC)', inline = 'VPOC_Display', tooltip = '是否显示成交量控制点 (VPOC)', group = group_vp)
vp_poc_color = input.color(color.new(#CFD8DC, 0), '', inline = 'VPOC_Display', group = group_vp)
vp_rows = input.int(200, '行数 (Rows)', 10, 500, tooltip = '用于构建成交量分布图的价格级别/行数', group = group_vp)
vp_va_max_iterations = input.int(250, 'VA Max Iterations', group=group_vp, minval=10, maxval=500, tooltip='Maximum iterations for Value Area calculation. Default is 250. Max value should not exceed max vp_rows (500).')
vp_poc_change_threshold_percent = input.float(10.0, "POC Change Threshold % (VA Recalc)", group=group_vp, minval=0.0, maxval=100.0, step=0.1, tooltip="Recalculate Value Area only if POC shifts by more than this % of profile price range. 0 to disable.")
vp_volume_change_threshold_percent = input.float(5.0, "Volume Change Threshold % (Redraw)", group=group_vp, minval=0.0, maxval=100.0, step=0.1, tooltip="Redraw profile polyline only if total volume changes by this % OR if POC/VA changes. 0 to disable.")
vp_profile_tf = input.timeframe('W', '分布图时间框架 (Profile Timeframe)', tooltip = '成交量分布图所代表的聚合时间框架', group = group_vp)
vp_resolution_tf = input.timeframe('3', '解析度时间框架 (Resolution Timeframe)', tooltip = '用于构建成交量分布图的更低级别时间框架数据', group = group_vp)
vp_extend_profile_percent = input.int(30, '分布图延伸 % (Profile Extend %)', 0, 100, tooltip = '成交量分布图应延伸到下一个周期的百分比', group = group_vp)
vp_label_offset_bars = input.int(5, 'VPOC标签偏移柱数 (VPOC Label Offset Bars)', 1, 100, group = group_vp, tooltip = '当前VPOC标签的柱偏移量')
vp_price_format = input.string('#.##', 'VPOC价格格式 (VPOC Price Format)', group = group_vp)


// =============================================================================
// ==== GLOBAL VARIABLE DECLARATIONS ====
// =============================================================================

var int cached_day = na
var int cached_month = na
var int cached_year = na
var int cached_quarter = na
var int cached_dayofweek = na
var int prev_bar_index = na
var bool is_new_day = false
var bool is_new_week = false
var bool is_new_month = false
var bool is_new_quarter = false
var bool is_new_year = false

var line[] line_pool = array.new_line()
var label[] label_pool = array.new_label()
var bool[] line_used_map = array.new_bool()
var bool[] label_used_map = array.new_bool()

initialize_object_pools() => // Function to initialize object pools
    if array.size(line_pool) == 0
        for i = 0 to 199
            line_obj = line.new(x1=0, y1=0, x2=0, y2=0, color=color.white, width=1, xloc=xloc.bar_time, style=DEFAULT_LINE_STYLE)
            array.push(line_pool, line_obj)
            array.push(line_used_map, false)
    if array.size(label_pool) == 0
        for i = 0 to 199
            label_obj = label.new(x=0, y=0, text="", color=color.white, textcolor=color.black, style=DEFAULT_LABEL_STYLE, xloc=xloc.bar_time, text_font_family=FONT_MONO)
            array.push(label_pool, label_obj)
            array.push(label_used_map, false)

get_line_from_pool() => // Function to get a line object from the pool
    initialize_object_pools()
    line result = na
    int pool_size = array.size(line_pool)
    
    // Simplified single linear scan
    for i = 0 to pool_size - 1
        if not array.get(line_used_map, i)
            array.set(line_used_map, i, true)
            result := array.get(line_pool, i)
            break
            
    if na(result) // If pool is exhausted, create a new one
        new_line = line.new(x1=0, y1=0, x2=0, y2=0, color=color.white, width=1, xloc=xloc.bar_time, style=DEFAULT_LINE_STYLE)
        array.push(line_pool, new_line)
        array.push(line_used_map, true)
        result := new_line
    result

get_label_from_pool() => // Function to get a label object from the pool
    initialize_object_pools()
    label result = na
    int pool_size = array.size(label_pool)

    // Simplified single linear scan
    for i = 0 to pool_size - 1
        if not array.get(label_used_map, i)
            array.set(label_used_map, i, true)
            result := array.get(label_pool, i)
            break
            
    if na(result) // If pool is exhausted, create a new one
        new_label = label.new(x=0, y=0, text="", color=color.white, textcolor=color.black, style=DEFAULT_LABEL_STYLE, xloc=xloc.bar_time, text_font_family=FONT_MONO)
        array.push(label_pool, new_label)
        array.push(label_used_map, true)
        result := new_label
    result

return_line_to_pool(line_obj) => // Function to return a line object to the pool
    bool _return = false 
    if not na(line_obj)
        int pool_size = array.size(line_pool)
        bool found = false
        // Prioritize checking recently used / end of array
        int start_idx = pool_size - 1
        for i = 0 to math.min(10, pool_size) - 1 
            int idx = start_idx - i
            if idx >= 0 and idx < pool_size and array.get(line_pool, idx) == line_obj
                array.set(line_used_map, idx, false)
                found := true
                break
        if not found // Check beginning
            for i = 0 to math.min(9, pool_size - 1)
                if array.get(line_pool, i) == line_obj
                    array.set(line_used_map, i, false)
                    found := true
                    break
        if not found // Check in segments
            int segment_size = 50
            for segment_start = 10 to pool_size - 1 by segment_size
                if found 
                    break
                int segment_end = math.min(segment_start + segment_size - 1, pool_size - 1)
                for i = segment_start to segment_end
                    if array.get(line_pool, i) == line_obj
                        array.set(line_used_map, i, false)
                        found := true
                        break
        _return := found
    _return


return_label_to_pool(label_obj) => // Function to return a label object to the pool
    bool _return = false 
    if not na(label_obj)
        int pool_size = array.size(label_pool)
        bool found = false
        // Prioritize checking recently used / end of array
        int start_idx = pool_size - 1
        for i = 0 to math.min(10, pool_size) - 1
            int idx = start_idx - i
            if idx >= 0 and idx < pool_size and array.get(label_pool, idx) == label_obj
                array.set(label_used_map, idx, false)
                found := true
                break
        if not found // Check beginning
            for i = 0 to math.min(9, pool_size - 1)
                if array.get(label_pool, i) == label_obj
                    array.set(label_used_map, i, false) // Corrected: should be label_used_map
                    found := true
                    break
        if not found // Check in segments
            int segment_size = 50
            for segment_start = 10 to pool_size - 1 by segment_size
                if found
                    break
                int segment_end = math.min(segment_start + segment_size - 1, pool_size - 1)
                for i = segment_start to segment_end
                    if array.get(label_pool, i) == label_obj
                        array.set(label_used_map, i, false)
                        found := true
                        break
        _return := found
    _return


var label[] key_open_labels = array.new_label()
var label[] pvwap_labels = array.new_label()
var line[] key_open_lines = array.new_line()
var line[] pvwap_lines = array.new_line()

var float cache_yearlyOpen = na
var float cache_monthlyOpen = na
var float cache_weeklyOpen = na
var float cache_quarterlyOpen = na
var float cache_dailyOpen = na
var float cache_lastWeeklyPOC = na
var float cache_lastMonthlyPOC = na
var float cache_lastQuarterlyPOC = na
var float cache_lastYearlyPOC = na

var int thisWeekStart = na
var float lastWeeklyLower = na
var float lastWeeklyUpper = na
var float lastWeeklyPOC = na
var int thisMonthStart = na
var float lastMonthlyLower = na
var float lastMonthlyUpper = na
var float lastMonthlyPOC = na
var int thisQuarterStart = na
var float lastQuarterlyLower = na
var float lastQuarterlyUpper = na
var float lastQuarterlyPOC = na
var int thisYearStart = na
var float lastYearlyLower = na
var float lastYearlyUpper = na
var float lastYearlyPOC = na

var float monthlyOpen = na
var float yearlyOpen = na
var float weeklyOpen = na
var float quarterlyOpen = na
var float dailyOpen = na

var float mondayHigh = na
var float mondayLow = na
var int mondayStartBar = na
var int mondayEndBar = na
var float prevMondayHigh = na
var float prevMondayLow = na
var int prevMondayStartBar = na
var int prevWeekEndBar = na

var int prevMondayStartTime = na  
var int prevWeekEndTime = na     

// Volume Profile Global Variables
var array<line> vp_historical_pocs = array.new_line() // Stores historical VPOC lines
var array<polyline> vp_historical_profiles = array.new<polyline>(0) // 存储历史VP图形
var array<polyline> vp_historical_value_areas = array.new<polyline>(0) // 存储历史VP的Value Area
var int max_historical_profiles = 5 // 最大保存的历史VP图形数量
var array<float> vp_volume_values = array.new_float(0)    // Stores aggregated volume for each price row
var array<float> vp_row_low_prices = array.new_float(0)  // Stores low price boundary for each VP row
var array<float> vp_row_high_prices = array.new_float(0) // Stores high price boundary for each VP row
var array<int> vp_x_coords = array.new_int(0)        // Stores x-coordinates (time/bar_index) for profile points
var array<float> vp_y_coords = array.new_float(0)      // Stores y-coordinates (price levels) for profile points
var float vp_previous_poc_price = na
var array<float> vp_previous_volume_values = array.new_float(0)
var array<chart.point> vp_profile_points_array = array.new<chart.point>() // Stores points for drawing the polyline
var array<chart.point> vp_value_area_points_array = array.new<chart.point>() // Stores points for drawing value area
var polyline vp_current_profile_polyline = na        // The current volume profile polyline
var polyline vp_current_value_area_polyline = na     // The current value area polyline
var line vp_current_poc_main_line = na            // Line for the current VPOC (from profile start to current bar)
var line vp_current_poc_label_line = na           // Short line segment for the current VPOC label
var label vp_current_poc_label = na               // Label for the current VPOC
var int vp_last_bar_idx_profile_start = na        // Bar index at the start of the current VP period
var int vp_last_time_profile_start = na           // Time at the start of the current VP period
var float vp_last_profile_low = na                // 保存上一个周期的最低价格
var float vp_last_profile_high = na               // 保存上一个周期的最高价格
var int vp_value_area_low_idx = na                // Value Area的下界索引
var int vp_value_area_high_idx = na               // Value Area的上界索引


get_quarter(t) => // Function to get the quarter of a given time
    m = month(t)
    (m <= 3) ? 1 : (m <= 6) ? 2 : (m <= 9) ? 3 : 4

// =============================================================================
// ==== FUNCTIONS ====
// =============================================================================

detect_timeframe_changes() => // Function to detect timeframe changes
    current_day = dayofmonth(time)
    current_month = month(time)
    current_year = year(time)
    current_quarter = get_quarter(time)
    current_dayofweek = dayofweek(time)
    isNewDay = current_day != cached_day or current_month != cached_month
    isNewWeek = current_dayofweek == dayofweek.monday and cached_dayofweek != dayofweek.monday
    isNewMonth = current_month != cached_month
    isNewQuarter = current_quarter != cached_quarter
    isNewYear = current_year != cached_year
    [isNewDay, isNewWeek, isNewMonth, isNewQuarter, isNewYear, current_day, current_month, current_year, current_quarter, current_dayofweek]

get_adaptive_anchor_tf(vwap_type='default') => // Function to get adaptive anchor timeframe
    current_tf = timeframe.period
    if vwap_type == 'yearly' or vwap_type == 'pyvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15" or current_tf == "30" or current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "60"
    else if vwap_type == 'quarterly' or vwap_type == 'pqvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15" or current_tf == "30" or current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "45"
    else if vwap_type == 'monthly' or vwap_type == 'pmvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "30"
    else if vwap_type == 'weekly' or vwap_type == 'pwvwap'
        if current_tf == "1"
            "1"
        else if current_tf == "3"
            "3"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240" or current_tf == "D" or current_tf == "W"
            "240"
        else
            "15"
    else if vwap_type == 'daily'
        if current_tf == "1"
            "1"
        else if current_tf == "3"
            "3"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240" or current_tf == "D" or current_tf == "W" or current_tf == "M"
            "240"
        else
            "15"
    else // default
        if current_tf == "1" or current_tf == "3"
            "5"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "D"

f_rolling_vwap(days) => // Function to calculate rolling VWAP
    time_window = days * 24 * 60 * 60 * 1000
    sum_src_vol = pc.totalForTimeWhen(vwapSource * volume, time_window, true, 10)
    sum_vol = pc.totalForTimeWhen(volume, time_window, true, 10)
    sum_vol == 0 ? na : sum_src_vol / sum_vol

f_rolling_vwap_for_small_tf(days, ref_tf) => // Function to calculate rolling VWAP for small timeframes
    request.security(syminfo.tickerid, ref_tf, f_rolling_vwap(days))

f_is_new_period(anchor) => // Function to check if it's a new period for anchored VWAP
    anchor_tf = switch anchor
        'Day'     => 'D'
        'Week'    => 'W'
        'Month'   => 'M'
        'Quarter' => '3M'
        'Year'    => '12M'
        => '' // Default case
    anchor_tf == '' ? false : timeframe.change(anchor_tf)


calculate_basic_vwap(src, reset_condition) => // Function to calculate basic VWAP and bands
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    [_vwap, _stdev_upper_band, _] = ta.vwap(src, reset_condition, 1)
    if not na(_vwap)
        vwapValue := _vwap
        if not na(_stdev_upper_band)
            stdev_abs = _stdev_upper_band - vwapValue
            upperBand := vwapValue + stdev_abs
            lowerBand := vwapValue - stdev_abs
        else
            upperBand := na
            lowerBand := na
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap_native(src, is_active, is_new_period) => // Function to calculate current VWAP natively
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    if is_active and not timeframe.isdwm
        [_vwap, _stdev_upper_band, _] = ta.vwap(src, is_new_period, 1)
        if not na(_vwap)
            vwapValue := _vwap
            if not na(_stdev_upper_band)
                stdev_abs = _stdev_upper_band - vwapValue
                upperBand := vwapValue + stdev_abs
                lowerBand := vwapValue - stdev_abs
            else
                upperBand := na
                lowerBand := na
        else
            vwapValue := na
            upperBand := na
            lowerBand := na
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap_adaptive(src, is_active, anchor_period) => // Function to calculate current VWAP adaptively
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    if is_active
        string vwap_type = 'default'
        if anchor_period == 'Year'
            vwap_type := 'yearly'
        else if anchor_period == 'Quarter'
            vwap_type := 'quarterly'
        else if anchor_period == 'Month'
            vwap_type := 'monthly'
        else if anchor_period == 'Week'
            vwap_type := 'weekly'
        else if anchor_period == 'Day'
            vwap_type := 'daily'
        ref_tf = get_adaptive_anchor_tf(vwap_type)
        isWeekStart = dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday)
        isMonthStart = month(time) != month(time[1])
        isQuarterStart = get_quarter(time) != get_quarter(time[1])
        isYearStart = year(time) != year(time[1])
        isDayStart = dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1])
        period_start_condition = anchor_period == 'Week' ? isWeekStart : anchor_period == 'Month' ? isMonthStart : anchor_period == 'Quarter' ? isQuarterStart : anchor_period == 'Year' ? isYearStart : anchor_period == 'Day' ? isDayStart : true
        reset_condition = request.security(syminfo.tickerid, ref_tf, period_start_condition, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
        [vwap_value_sec, upper_band_sec, lower_band_sec] = request.security(syminfo.tickerid, ref_tf, calculate_basic_vwap(src, reset_condition), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
        vwapValue := vwap_value_sec
        upperBand := upper_band_sec
        lowerBand := lower_band_sec
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap(src, is_active, is_new_period_val, anchor_type) => // Unified function to calculate current VWAP
    if anchor_type == 'Day' and not use_adaptive_tf
        f_calculate_current_vwap_native(src, is_active, is_new_period_val)
    else
        f_calculate_current_vwap_adaptive(src, is_active, anchor_type)

get_fixed_tf_vwap(src, period_type) => // Function to get VWAP for a fixed timeframe
    string vwap_type = 'default'
    if period_type == 'Y'
        vwap_type := 'pyvwap'
    else if period_type == 'Q'
        vwap_type := 'pqvwap'
    else if period_type == 'M'
        vwap_type := 'pmvwap'
    else if period_type == 'W'
        vwap_type := 'pwvwap'
    else if period_type == 'D'
        vwap_type := 'daily'
    ref_tf = get_adaptive_anchor_tf(vwap_type)
    reset_condition_sec = request.security(syminfo.tickerid, ref_tf, period_type == 'W' ? dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday) : period_type == 'M' ? month(time) != month(time[1]) : period_type == 'Q' ? get_quarter(time) != get_quarter(time[1]) : period_type == 'Y' ? year(time) != year(time[1]) : period_type == 'D' ? dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1]) : false, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    [vwap_value_sec, upper_band_sec, lower_band_sec] = request.security(syminfo.tickerid, ref_tf, calculate_basic_vwap(src, reset_condition_sec), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    [vwap_value_sec, upper_band_sec, lower_band_sec]

calculate_period_vwap(src, tf_string) => // Function to calculate period VWAP
    isNewPeriod = timeframe.change(tf_string)
    [vwapVal, upperVal, lowerVal] = calculate_basic_vwap(src, isNewPeriod)
    [vwapVal, upperVal, lowerVal]

detect_period_change(period) => // Function to detect period change
    switch period
        'W' => dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday)
        'M' => month(time) != month(time[1])
        'Q' => get_quarter(time) != get_quarter(time[1])
        'Y' => year(time) != year(time[1])
        => false

calculate_and_store_previous_vwap(period) => // Function to calculate and store previous period VWAP
    is_tf_change = detect_period_change(period)
    float poc = na
    float upper = na
    float lower = na
    int start_index = na
    [cur_poc, cur_upper, cur_lower] = get_fixed_tf_vwap(vwapSource, period)
    if is_tf_change
        poc := cur_poc[1]
        upper := cur_upper[1]
        lower := cur_lower[1]
        start_index := bar_index
    [poc, upper, lower, start_index]

plot_previous_vwap_levels(anchor_str, p_upper, p_lower, p_poc, p_start_bar, vwap_plot_color) => // Function to plot previous VWAP levels
    if not na(p_poc) and not na(p_start_bar)
        int offset_time = time + (pvwap_offset * timeframe.in_seconds(timeframe.period) * 1000) 
        int line_start_time = offset_time - (KEYLEVEL_LINE_LENGTH * timeframe.in_seconds(timeframe.period) * 1000) 
        color labelTextColor = color.new(vwap_plot_color, 45)
        color shortLineColor = color.new(vwap_plot_color, 30)
        string lower_label_text = ""
        string poc_label_text = ""
        string upper_label_text = ""
        if anchor_str == 'Week'
            lower_label_text := "pWvaL"
            poc_label_text := "pWvwap"
            upper_label_text := "pWvaH"
        else if anchor_str == 'Month'
            lower_label_text := "pMvaL"
            poc_label_text := "pMvwap"
            upper_label_text := "pMvaH"
        else if anchor_str == 'Quarter'
            lower_label_text := "pQvaL"
            poc_label_text := "pQvwap"
            upper_label_text := "pQvaH"
        else if anchor_str == 'Year'
            lower_label_text := "pYvaL"
            poc_label_text := "pYvwap"
            upper_label_text := "pYvaH"
        else
            prefix = switch anchor_str
                'Week'    => 'pw'
                'Month'   => 'pm'
                'Quarter' => 'pq'
                'Year'    => 'py'
                => 'p'
            lower_label_text := prefix + 'VWAP -1'
            poc_label_text := prefix + 'VWAP'
            upper_label_text := prefix + 'VWAP +1'
        if not na(p_lower)
            line_lower = get_line_from_pool()
            line_lower.set_xy1(line_start_time, p_lower)
            line_lower.set_xy2(offset_time, p_lower)
            line_lower.set_color(shortLineColor)
            line_lower.set_width(1)
            line_lower.set_style(PVWAP_LINE_STYLE)
            array.push(pvwap_lines, line_lower)
            lbl_lower = get_label_from_pool()
            lbl_lower.set_xy(offset_time, p_lower)
            lbl_lower.set_text(lower_label_text)
            lbl_lower.set_tooltip(str.tostring(p_lower, pvwap_format_level))
            lbl_lower.set_color(label_color_setting)
            lbl_lower.set_textcolor(labelTextColor)
            lbl_lower.set_style(DEFAULT_LABEL_STYLE)
            lbl_lower.set_text_font_family(FONT_MONO)
            array.push(pvwap_labels, lbl_lower)
        if not na(p_upper)
            line_upper = get_line_from_pool()
            line_upper.set_xy1(line_start_time, p_upper)
            line_upper.set_xy2(offset_time, p_upper)
            line_upper.set_color(shortLineColor)
            line_upper.set_width(1)
            line_upper.set_style(PVWAP_LINE_STYLE)
            array.push(pvwap_lines, line_upper)
            lbl_upper = get_label_from_pool()
            lbl_upper.set_xy(offset_time, p_upper)
            lbl_upper.set_text(upper_label_text)
            lbl_upper.set_tooltip(str.tostring(p_upper, pvwap_format_level))
            lbl_upper.set_color(label_color_setting)
            lbl_upper.set_textcolor(labelTextColor)
            lbl_upper.set_style(DEFAULT_LABEL_STYLE)
            lbl_upper.set_text_font_family(FONT_MONO)
            array.push(pvwap_labels, lbl_upper)
        line_poc = get_line_from_pool()
        line_poc.set_xy1(line_start_time, p_poc)
        line_poc.set_xy2(offset_time, p_poc)
        line_poc.set_color(shortLineColor)
        line_poc.set_width(1)
        line_poc.set_style(PVWAP_LINE_STYLE)
        array.push(pvwap_lines, line_poc)
        lbl_poc = get_label_from_pool()
        lbl_poc.set_xy(offset_time, p_poc)
        lbl_poc.set_text(poc_label_text)
        lbl_poc.set_tooltip(str.tostring(p_poc, pvwap_format_level))
        lbl_poc.set_color(label_color_setting)
        lbl_poc.set_textcolor(labelTextColor)
        lbl_poc.set_style(DEFAULT_LABEL_STYLE)
        lbl_poc.set_text_font_family(FONT_MONO)
        array.push(pvwap_labels, lbl_poc)

plot_key_open_level(levelValue, levelName, levelColor, offset_val, format_str) => // Function to plot key open levels
    if not na(levelValue)
        int offset_time = time + (offset_val * timeframe.in_seconds(timeframe.period) * 1000) 
        int line_start_time = offset_time - (KEYLEVEL_LINE_LENGTH * timeframe.in_seconds(timeframe.period) * 1000) 
        color lineColor = levelColor
        color bgColor = label_color_setting
        color labelTextColor = switch levelName
            "YO" => color.new(#009688, 45)
            "QO" => color.new(#FF4081, 45)
            "MO" => color.new(#00E676, 45)
            "WO" => color.new(#29B6F6, 45)
            "DO" => color.new(color_DailyOpen, 45)
            => color.new(levelColor, 45)
        line_obj = get_line_from_pool()
        line_obj.set_xy1(line_start_time, levelValue)
        line_obj.set_xy2(offset_time, levelValue)
        line_obj.set_color(lineColor)
        line_obj.set_width(1)
        line_obj.set_style(PVWAP_LINE_STYLE)
        array.push(key_open_lines, line_obj)
        label_obj = get_label_from_pool()
        label_obj.set_xy(offset_time, levelValue)
        label_obj.set_text(levelName)
        label_obj.set_tooltip(str.tostring(levelValue, format_str))
        label_obj.set_color(bgColor)
        label_obj.set_textcolor(labelTextColor)
        label_obj.set_style(DEFAULT_LABEL_STYLE)
        label_obj.set_text_font_family(FONT_MONO)
        array.push(key_open_labels, label_obj)

f_get_yearly_open() => // Function to get yearly open price
    var float yo = na
    if year(time) != year(time[1]) or na(yo)
        yo := open
    yo

f_get_monthly_open() => // Function to get monthly open price
    var float mo = na
    if month(time) != month(time[1]) or na(mo)
        mo := open
    mo

f_get_quarterly_open() => // Function to get quarterly open price
    var float qo = na
    if get_quarter(time) != get_quarter(time[1]) or na(qo)
        qo := open
    qo

f_get_weekly_open() => // Function to get weekly open price
    var float wo = na
    if dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday or na(wo))
        wo := open
    wo

f_get_daily_open() => // Function to get daily open price
    var float d_open = na
    if dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1]) or na(d_open)
        d_open := open
    d_open

yearOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_yearly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
monthOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_monthly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
quarterOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_quarterly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
weekOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_weekly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
dailyOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_daily_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na

// =============================================================================
// ==== CALCULATIONS (Main Script Logic) ====
// =============================================================================

[isNewDay, isNewWeek, isNewMonth, isNewQuarter, isNewYear, current_day, current_month, current_year, current_quarter, current_dayofweek] = detect_timeframe_changes()

cached_day := current_day
cached_month := current_month
cached_year := current_year
cached_quarter := current_quarter
cached_dayofweek := current_dayofweek

bool is_small_tf = timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds("60") 
rvwap_7d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(7, rvwap_ref_tf) : f_rolling_vwap(7)
rvwap_30d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(30, rvwap_ref_tf) : f_rolling_vwap(30)
rvwap_90d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(90, rvwap_ref_tf) : f_rolling_vwap(90)
rvwap_365d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(365, rvwap_ref_tf) : f_rolling_vwap(365)

rvwap_7d = ta.sma(rvwap_7d_raw, rvwap_smoothing)
rvwap_30d = ta.sma(rvwap_30d_raw, rvwap_smoothing)
rvwap_90d = ta.sma(rvwap_90d_raw, rvwap_smoothing)
rvwap_365d = ta.sma(rvwap_365d_raw, rvwap_smoothing)

[vwap1, band1_upper, band1_lower] = f_calculate_current_vwap(vwapSource, VWAP1_Ctl, f_is_new_period(Anchor1), Anchor1)
[vwap2, band2_upper, band2_lower] = f_calculate_current_vwap(vwapSource, VWAP2_Ctl, f_is_new_period(Anchor2), Anchor2)
[vwap3, band3_upper, band3_lower] = f_calculate_current_vwap(vwapSource, VWAP3_Ctl, f_is_new_period(Anchor3), Anchor3)

string curr_tf_period = timeframe.period
int current_tf_seconds_val = timeframe.in_seconds(timeframe.period) 

int SECONDS_4H_VAL = 4 * 60 * 60
int SECONDS_12H_VAL = 12 * 60 * 60
int SECONDS_1D_VAL = 24 * 60 * 60
int SECONDS_1W_VAL = 7 * 24 * 60 * 60

bool is_4h_or_higher_tf = current_tf_seconds_val >= SECONDS_4H_VAL
bool is_12h_or_higher_tf = current_tf_seconds_val >= SECONDS_12H_VAL
bool is_weekly_or_higher_tf = current_tf_seconds_val >= SECONDS_1W_VAL
bool is_monthly_or_higher_tf = curr_tf_period == "M" or curr_tf_period == "3M" or curr_tf_period == "6M" or curr_tf_period == "12M"

[vwap4, band4_upper, band4_lower] = f_calculate_current_vwap(vwapSource, VWAP4_Ctl, f_is_new_period(Anchor4), Anchor4)
[vwap5, band5_upper, band5_lower] = f_calculate_current_vwap(vwapSource, VWAP5_Ctl, f_is_new_period(Anchor5), Anchor5)

[yearly_period_vwap, yearly_period_upper, yearly_period_lower] = calculate_period_vwap(vwapSource, '12M')
[quarterly_period_vwap, quarterly_period_upper, quarterly_period_lower] = calculate_period_vwap(vwapSource, '3M')
[monthly_period_vwap, monthly_period_upper, monthly_period_lower] = calculate_period_vwap(vwapSource, 'M')
[weekly_period_vwap, weekly_period_upper, weekly_period_lower] = calculate_period_vwap(vwapSource, 'W')

[yearly_poc_val, yearly_upper_val, yearly_lower_val, yearly_start_val] = calculate_and_store_previous_vwap('Y')
[quarterly_poc_val, quarterly_upper_val, quarterly_lower_val, quarterly_start_val] = calculate_and_store_previous_vwap('Q')
[monthly_poc_val, monthly_upper_val, monthly_lower_val, monthly_start_val] = calculate_and_store_previous_vwap('M')
[weekly_poc_val, weekly_upper_val, weekly_lower_val, weekly_start_val] = calculate_and_store_previous_vwap('W')


if not na(weekly_poc_val) and not na(weekly_start_val)
    lastWeeklyPOC := weekly_poc_val
    lastWeeklyUpper := weekly_upper_val
    lastWeeklyLower := weekly_lower_val
    thisWeekStart := int(weekly_start_val)
else if isNewWeek
    lastWeeklyLower := weekly_period_lower[1]
    lastWeeklyUpper := weekly_period_upper[1]
    lastWeeklyPOC := weekly_period_vwap[1]
    thisWeekStart := bar_index

if not na(monthly_poc_val) and not na(monthly_start_val)
    lastMonthlyPOC := monthly_poc_val
    lastMonthlyUpper := monthly_upper_val
    lastMonthlyLower := monthly_lower_val
    thisMonthStart := int(monthly_start_val)
else if isNewMonth
    lastMonthlyLower := monthly_period_lower[1]
    lastMonthlyUpper := monthly_period_upper[1]
    lastMonthlyPOC := monthly_period_vwap[1]
    thisMonthStart := bar_index

if not na(quarterly_poc_val) and not na(quarterly_start_val)
    lastQuarterlyPOC := quarterly_poc_val
    lastQuarterlyUpper := quarterly_upper_val
    lastQuarterlyLower := quarterly_lower_val
    thisQuarterStart := int(quarterly_start_val)
else if isNewQuarter
    lastQuarterlyLower := quarterly_period_lower[1]
    lastQuarterlyUpper := quarterly_period_upper[1]
    lastQuarterlyPOC := quarterly_period_vwap[1]
    thisQuarterStart := bar_index

if not na(yearly_poc_val) and not na(yearly_start_val)
    lastYearlyPOC := yearly_poc_val
    lastYearlyUpper := yearly_upper_val
    lastYearlyLower := yearly_lower_val
    thisYearStart := int(yearly_start_val)
else if isNewYear
    lastYearlyLower := yearly_period_lower[1]
    lastYearlyUpper := yearly_period_upper[1]
    lastYearlyPOC := yearly_period_vwap[1]
    thisYearStart := bar_index

bool valid_yearOpen_val = not na(yearOpen_ref) and yearOpen_ref > 0
bool valid_monthOpen_val = not na(monthOpen_ref) and monthOpen_ref > 0
bool valid_weekOpen_val = not na(weekOpen_ref) and weekOpen_ref > 0
bool valid_quarterOpen_val = not na(quarterOpen_ref) and quarterOpen_ref > 0
bool valid_dailyOpen_val = not na(dailyOpen_ref) and dailyOpen_ref > 0

if isNewMonth or na(monthlyOpen[1])
    monthlyOpen := valid_monthOpen_val and use_ref_tf_for_opens ? monthOpen_ref : open
if isNewYear or na(yearlyOpen[1])
    yearlyOpen := valid_yearOpen_val and use_ref_tf_for_opens ? yearOpen_ref : open
if isNewWeek or na(weeklyOpen[1])
    weeklyOpen := valid_weekOpen_val and use_ref_tf_for_opens ? weekOpen_ref : open
if isNewQuarter or na(quarterlyOpen[1])
    quarterlyOpen := valid_quarterOpen_val and use_ref_tf_for_opens ? quarterOpen_ref : open 
if isNewDay or na(dailyOpen[1])
    dailyOpen := valid_dailyOpen_val and use_ref_tf_for_opens ? dailyOpen_ref : open

bool isMondayNow = dayofweek(time) == dayofweek.monday
if isNewWeek
    prevMondayHigh := mondayHigh
    prevMondayLow := mondayLow
    prevMondayStartBar := mondayStartBar
    prevWeekEndBar := bar_index[1]
    mondayHigh := na
    mondayLow := na
    mondayStartBar := na
    mondayEndBar := na
    if not na(mondayStartBar) and (bar_index - mondayStartBar >=0) 
        prevMondayStartTime := time[bar_index - mondayStartBar] 
    else
        prevMondayStartTime := na 
    prevWeekEndTime := time[1]  
if isMondayNow
    if na(mondayStartBar)
        mondayStartBar := bar_index
        mondayHigh := high
        mondayLow := low
    else
        mondayHigh := math.max(na(mondayHigh) ? high : mondayHigh, high)
        mondayLow := math.min(na(mondayLow) ? low : mondayLow, low)
    mondayEndBar := bar_index

// ---- Volume Profile Calculations ----
if vp_enable
    vp_res_tf_str = timeframe.in_seconds(vp_resolution_tf) <= timeframe.in_seconds() ? vp_resolution_tf : timeframe.period
    [ltf_H_arr, ltf_L_arr, ltf_V_arr] = request.security_lower_tf(syminfo.tickerid, vp_res_tf_str, [high, low, volume])

    // 更新最大历史配置文件数量
    max_historical_profiles := vp_max_history

    if not na(vp_last_bar_idx_profile_start)
        // Determine the lookback period for the current profile
        lookback_bars = bar_index - vp_last_bar_idx_profile_start > 0 ? bar_index - vp_last_bar_idx_profile_start : 1

        // Determine high and low for the current profile period
        profile_high_price = ta.highest(high[1], lookback_bars) // Use high[1] to avoid current bar's forming high
        profile_low_price = ta.lowest(low[1], lookback_bars)   // Use low[1] to avoid current bar's forming low

        // Recalculate profile on new period or on the last bar
        is_new_vp_period = timeframe.change(vp_profile_tf)
        if is_new_vp_period or barstate.islast
            // Optimize vp_volume_values initialization
            if array.size(vp_volume_values) != vp_rows and vp_rows > 0
                array.clear(vp_volume_values) // Clear before resizing by push
                for _ = 0 to vp_rows - 1
                    array.push(vp_volume_values, 0.0) 
            else if vp_rows > 0 // Size is already correct
                for i_fill = 0 to vp_rows - 1
                    array.set(vp_volume_values, i_fill, 0.0)
            else // vp_rows is 0 or less
                array.clear(vp_volume_values)

            // Precompute Price-to-Row Mapping (vp_row_low_prices, vp_row_high_prices)
            // Ensure these are sized correctly if vp_rows changes.
            if array.size(vp_row_low_prices) != vp_rows and vp_rows > 0 // Covers size change for vp_row_high_prices too
                array.clear(vp_row_low_prices)
                array.clear(vp_row_high_prices)
                for _ = 0 to vp_rows - 1
                    array.push(vp_row_low_prices, na) // Push to establish size
                    array.push(vp_row_high_prices, na) // Push to establish size
            else if vp_rows <= 0 
                array.clear(vp_row_low_prices)
                array.clear(vp_row_high_prices)
            // If size is correct and vp_rows > 0, they will be populated by array.set later.
            
            float _price_step = (vp_rows > 1 and profile_high_price > profile_low_price) ? (profile_high_price - profile_low_price) / (vp_rows - 1) : 0.0

            if vp_rows > 0
                for j_map = 0 to vp_rows - 1
                    if _price_step > 0 // Standard case with price range
                        array.set(vp_row_low_prices, j_map, profile_low_price + j_map * _price_step)
                        array.set(vp_row_high_prices, j_map, profile_low_price + (j_map + 1) * _price_step)
                    else // Flat profile or single row
                        array.set(vp_row_low_prices, j_map, profile_low_price)
                        array.set(vp_row_high_prices, j_map, profile_high_price) 

                if vp_rows > 0 and _price_step > 0 
                     array.set(vp_row_high_prices, vp_rows - 1, profile_high_price)
                if vp_rows > 0
                    array.set(vp_row_low_prices, 0, profile_low_price)

            // Optimize vp_y_coords initialization (Price Levels for Rows)
            if array.size(vp_y_coords) != vp_rows and vp_rows > 0
                array.clear(vp_y_coords)
                for _ = 0 to vp_rows - 1
                    array.push(vp_y_coords, 0.0) // Push to establish size
            // No 'else if' for filling here, as it's populated directly after based on vp_row_low_prices.
            // If size is correct, it will be overwritten. If vp_rows is 0, it's cleared below.
            
            if vp_rows > 0 and array.size(vp_row_low_prices) == vp_rows // Ensure source array is ready
                for i_y = 0 to vp_rows - 1
                    array.set(vp_y_coords, i_y, array.get(vp_row_low_prices, i_y))
            else if vp_rows <= 0 // Handles vp_rows is 0 or less for vp_y_coords
                array.clear(vp_y_coords)

            // vp_x_coords will be initialized/cleared and populated later, before drawing.
            // Old initialization loops for vp_x_coords, vp_y_coords, vp_volume_values are now fully replaced.

            // Aggregate volume from lower timeframe data
            // _price_step is already calculated above (used by vp_row_low_prices/vp_row_high_prices)

            int end_bar_offset = barstate.islast ? 0 : 1
            for i = lookback_bars - end_bar_offset to 0 // Iterate over bars in the current profile period
                vol_at_bar_arr = ltf_V_arr[i] 
                high_at_bar_arr = ltf_H_arr[i]
                low_at_bar_arr = ltf_L_arr[i]

                if array.size(vol_at_bar_arr) > 0
                    for k = 0 to array.size(vol_at_bar_arr) - 1 // Iterate over LFT bars within the main bar
                        float ltf_bar_high = array.get(high_at_bar_arr, k)
                        float ltf_bar_low = array.get(low_at_bar_arr, k)
                        float ltf_bar_vol = array.get(vol_at_bar_arr, k)

                        if ltf_bar_vol > 0 and vp_rows > 0 and profile_high_price >= profile_low_price and array.size(vp_row_low_prices) == vp_rows
                            var int rows_spanned_by_ltf_bar = 0
                            var array<bool> ltf_bar_spanned_rows_flags = array.new_bool(vp_rows, false) 
                            if array.size(ltf_bar_spanned_rows_flags) != vp_rows 
                                ltf_bar_spanned_rows_flags := array.new_bool(vp_rows, false)
                            else
                                array.fill(ltf_bar_spanned_rows_flags, false)

                            for j_span_check = 0 to vp_rows - 1
                                float row_low = array.get(vp_row_low_prices, j_span_check)
                                float row_high = array.get(vp_row_high_prices, j_span_check)
                                
                                bool overlaps = math.max(ltf_bar_low, row_low) < math.min(ltf_bar_high, row_high)
                                if row_low == row_high and ltf_bar_low == ltf_bar_high
                                    overlaps := ltf_bar_low == row_low
                                else if row_low == row_high 
                                    overlaps := ltf_bar_low <= row_low and ltf_bar_high >= row_high

                                if overlaps
                                    array.set(ltf_bar_spanned_rows_flags, j_span_check, true)
                                    rows_spanned_by_ltf_bar += 1
                            
                            if rows_spanned_by_ltf_bar > 0
                                float vol_per_spanned_row = ltf_bar_vol / rows_spanned_by_ltf_bar
                                for j_distribute = 0 to vp_rows - 1
                                    if array.get(ltf_bar_spanned_rows_flags, j_distribute)
                                        array.set(vp_volume_values, j_distribute, array.get(vp_volume_values, j_distribute) + vol_per_spanned_row)

            // Find VPOC (price level with max volume)
            // Ensure vp_volume_values is not empty before calling array.max, though it's initialized with vp_rows elements.
            max_volume_for_poc = array.size(vp_volume_values) > 0 ? array.max(vp_volume_values) : 0.0
            poc_price = array.get(vp_y_coords, array.indexof(vp_volume_values, max_volume_for_poc)) // Assumes vp_y_coords is populated and valid

            // ---- Incremental Update Logic ----
            bool should_recalculate_va = true 
            if vp_poc_change_threshold_percent > 0.0 and not na(vp_previous_poc_price) and not na(poc_price) and profile_high_price > profile_low_price and array.size(vp_volume_values) > 0
                poc_change_abs = math.abs(poc_price - vp_previous_poc_price)
                price_range = profile_high_price - profile_low_price
                if price_range > 0
                    poc_change_as_percent_of_range = (poc_change_abs / price_range) * 100.0
                    if poc_change_as_percent_of_range < vp_poc_change_threshold_percent
                        should_recalculate_va := false
                else 
                    if poc_price == vp_previous_poc_price
                        should_recalculate_va := false
            else if na(vp_previous_poc_price) 
                 should_recalculate_va := true

            float current_total_volume = array.sum(vp_volume_values)
            float previous_total_volume = array.size(vp_previous_volume_values) > 0 ? array.sum(vp_previous_volume_values) : 0.0
            
            bool significant_volume_change = true 
            if vp_volume_change_threshold_percent > 0.0 and previous_total_volume > 0 and current_total_volume > 0 and array.size(vp_previous_volume_values) > 0
                volume_diff_percent = (math.abs(current_total_volume - previous_total_volume) / previous_total_volume) * 100.0
                if volume_diff_percent < vp_volume_change_threshold_percent and not should_recalculate_va
                    significant_volume_change := false
            else if array.size(vp_previous_volume_values) == 0 // First run for this profile, always consider significant
                significant_volume_change := true
            
            // ---- End Incremental Update Logic ----

            // 计算Value Area（包含70%总成交量的区域）
            if should_recalculate_va // Only calculate VA if needed
                vp_value_area_low_idx := na
                vp_value_area_high_idx := na
                
                float total_volume = current_total_volume // Use already calculated current_total_volume
                    
                if total_volume > 0
                    int poc_index = array.indexof(vp_volume_values, max_volume_for_poc)
                    float target_volume = total_volume * 0.7  
                    float current_va_calc_volume = array.get(vp_volume_values, poc_index)
                    
                    vp_value_area_low_idx := poc_index
                    vp_value_area_high_idx := poc_index
                    
                    int l_ptr = poc_index - 1
                    int r_ptr = poc_index + 1
                    int va_iterations = 0 
                    
                    while current_va_calc_volume < target_volume and va_iterations < vp_va_max_iterations and va_iterations < vp_rows 
                        float vol_left = l_ptr >= 0 ? array.get(vp_volume_values, l_ptr) : 0.0
                        float vol_right = r_ptr < array.size(vp_volume_values) ? array.get(vp_volume_values, r_ptr) : 0.0
                        
                        if vol_left <= 0 and vol_right <= 0
                            break  
                        
                        if vol_left >= vol_right or (vol_left > 0 and vol_right <= 0) 
                            current_va_calc_volume += vol_left
                            vp_value_area_low_idx := l_ptr
                            l_ptr -= 1
                        else
                            current_va_calc_volume += vol_right
                            vp_value_area_high_idx := r_ptr
                            r_ptr += 1
                        
                        va_iterations += 1 
            // else: VA indices (vp_value_area_low_idx, vp_value_area_high_idx) retain their values from previous calculation.

            // ---- Conditional Polyline Construction and Drawing ----
            bool force_redraw_profile = na(vp_current_profile_polyline) 
            bool condition_update_profile_geometry = significant_volume_change or should_recalculate_va or force_redraw_profile

            if condition_update_profile_geometry // Recalculate vp_x_coords and profile points if necessary
                max_aggregated_volume = array.size(vp_volume_values) > 0 ? array.max(vp_volume_values) : 1.0 
                max_aggregated_volume := max_aggregated_volume > 0 ? max_aggregated_volume : 1.0
                time_width_for_profile = 0.0 
                base_time_width = float(time[0] - vp_last_time_profile_start) 
                if vp_extend_profile_percent == 0
                    time_width_for_profile := base_time_width > 0 ? base_time_width : 1.0
                else
                    calculated_width = base_time_width * (vp_extend_profile_percent / 100.0)
                    time_width_for_profile := calculated_width > 0 ? calculated_width : 1.0
                time_width_for_profile := time_width_for_profile > 0 ? time_width_for_profile : 1.0
                scaling_factor = max_aggregated_volume / time_width_for_profile
                scaling_factor := scaling_factor > 0 ? scaling_factor : 1.0 

                if array.size(vp_x_coords) != vp_rows and vp_rows > 0
                    array.clear(vp_x_coords) 
                    for _ = 0 to vp_rows - 1
                        array.push(vp_x_coords, vp_last_time_profile_start) 
                else if vp_rows > 0 
                     for i_fill_x = 0 to vp_rows - 1 
                        array.set(vp_x_coords, i_fill_x, vp_last_time_profile_start) 
                else 
                    array.clear(vp_x_coords)

                if vp_rows > 0 and array.size(vp_volume_values) == vp_rows and array.size(vp_x_coords) == vp_rows 
                    for j_x = 0 to vp_rows - 1 
                        if scaling_factor > 0
                            scaled_volume_as_time_offset = math.floor(array.get(vp_volume_values, j_x) / scaling_factor)
                            array.set(vp_x_coords, j_x, vp_last_time_profile_start + scaled_volume_as_time_offset)

                array.clear(vp_profile_points_array)
                array.push(vp_profile_points_array, chart.point.from_time(vp_last_time_profile_start, profile_low_price))
                if vp_rows > 0 and array.size(vp_x_coords) == vp_rows and array.size(vp_y_coords) == vp_rows
                    for i_poly = 0 to vp_rows - 1
                        array.push(vp_profile_points_array, chart.point.from_time(array.get(vp_x_coords, i_poly), array.get(vp_y_coords, i_poly)))
                array.push(vp_profile_points_array, chart.point.from_time(vp_last_time_profile_start, profile_high_price))

            // -- Main Profile Polyline Drawing --
            if vp_show_profile and condition_update_profile_geometry
                if not na(vp_current_profile_polyline)
                    vp_current_profile_polyline.delete()
                vp_current_profile_polyline := polyline.new(vp_profile_points_array, curved = false, closed = true, 
                                       line_color = vp_profile_color, fill_color = vp_profile_color, 
                                       xloc = xloc.bar_time)
            
            // -- Value Area Polyline Construction & Drawing --
            bool force_redraw_va = na(vp_current_value_area_polyline)
            bool condition_update_va_geometry = should_recalculate_va or (significant_volume_change and not na(vp_value_area_low_idx)) or force_redraw_va

            if condition_update_va_geometry and not na(vp_value_area_low_idx) and not na(vp_value_area_high_idx) and vp_value_area_low_idx >=0 and vp_value_area_high_idx < vp_rows and vp_value_area_low_idx <= vp_value_area_high_idx and array.size(vp_y_coords) == vp_rows and array.size(vp_x_coords) == vp_rows
                array.clear(vp_value_area_points_array)
                value_area_low_price = array.get(vp_y_coords, vp_value_area_low_idx)
                value_area_high_price = array.get(vp_y_coords, vp_value_area_high_idx)
                array.push(vp_value_area_points_array, chart.point.from_time(vp_last_time_profile_start, value_area_low_price))
                for i_va_poly = vp_value_area_low_idx to vp_value_area_high_idx
                    array.push(vp_value_area_points_array, chart.point.from_time(array.get(vp_x_coords, i_va_poly), array.get(vp_y_coords, i_va_poly)))
                array.push(vp_value_area_points_array, chart.point.from_time(vp_last_time_profile_start, value_area_high_price))

            if vp_show_profile and condition_update_va_geometry 
                if not na(vp_current_value_area_polyline)
                    vp_current_value_area_polyline.delete()
                // Ensure points were actually built before drawing
                if array.size(vp_value_area_points_array) > 2
                    vp_current_value_area_polyline := polyline.new(vp_value_area_points_array, curved = false, closed = true, 
                                                       line_color = vp_value_area_color, fill_color = vp_value_area_color, 
                                                       xloc = xloc.bar_time)
                else // If no points, ensure polyline is na
                    vp_current_value_area_polyline := na


            // Store current POC and volume data for next bar's comparison
            vp_previous_poc_price := poc_price
            if array.size(vp_previous_volume_values) != array.size(vp_volume_values) and array.size(vp_volume_values) > 0
                array.clear(vp_previous_volume_values)
                for vol_val_copy_idx = 0 to array.size(vp_volume_values) - 1 // Iterate with index for new_float(0) compatibility
                    array.push(vp_previous_volume_values, array.get(vp_volume_values, vol_val_copy_idx))
            else if array.size(vp_volume_values) > 0
                for i_vol_copy = 0 to array.size(vp_volume_values) - 1
                    array.set(vp_previous_volume_values, i_vol_copy, array.get(vp_volume_values, i_vol_copy))
            else
                array.clear(vp_previous_volume_values) 

            // Handle VPOC lines and labels (Original logic for is_new_vp_period and barstate.islast for VPOC labels)
            // Handle VPOC lines and labels (This part seems to be mostly for historical and current POC display, may not need full conditionalization based on geometry change flags, but rather on is_new_vp_period or barstate.islast)
            if is_new_vp_period
                // 添加当前的VP图形到历史数组中
                if vp_show_historical and not na(vp_current_profile_polyline) 
                    // 创建一个新的点数组用于历史VP
                    var array<chart.point> historical_points = array.new<chart.point>()
                    array.clear(historical_points)
                    
                    // 添加底部点
                    array.push(historical_points, chart.point.from_time(vp_last_time_profile_start, profile_low_price))
                    
                    // 添加右侧点
                    for i = 0 to array.size(vp_x_coords) - 1
                        if not na(array.get(vp_x_coords, i)) and not na(array.get(vp_y_coords, i))
                            array.push(historical_points, chart.point.from_time(array.get(vp_x_coords, i), array.get(vp_y_coords, i)))
                    
                    // 添加顶部点
                    array.push(historical_points, chart.point.from_time(vp_last_time_profile_start, profile_high_price))
                    
                    // 创建历史VP图形
                    if array.size(historical_points) > 2
                        historical_profile = polyline.new(historical_points, curved = false, closed = true, 
                                               line_color = vp_historical_color, fill_color = vp_historical_color, 
                                               xloc = xloc.bar_time)
                        array.unshift(vp_historical_profiles, historical_profile)
                        
                        // 限制历史VP数量
                        if array.size(vp_historical_profiles) > max_historical_profiles
                            old_profile = array.pop(vp_historical_profiles)
                            polyline.delete(old_profile)
                            
                    // 如果有Value Area数据，也保存为历史Value Area
                    if not na(vp_value_area_low_idx) and not na(vp_value_area_high_idx) and array.size(vp_value_area_points_array) > 2
                        var array<chart.point> historical_va_points = array.new<chart.point>()
                        array.clear(historical_va_points)
                        
                        // 复制当前的Value Area点到历史Value Area
                        for i = 0 to array.size(vp_value_area_points_array) - 1
                            array.push(historical_va_points, array.get(vp_value_area_points_array, i))
                        
                        if array.size(historical_va_points) > 2
                            historical_va = polyline.new(historical_va_points, curved = false, closed = true, 
                                              line_color = vp_value_area_color, fill_color = vp_value_area_color, 
                                              xloc = xloc.bar_time)
                            array.unshift(vp_historical_value_areas, historical_va)
                            
                            // 限制历史Value Area数量
                            if array.size(vp_historical_value_areas) > max_historical_profiles
                                old_va = array.pop(vp_historical_value_areas)
                                polyline.delete(old_va)

                // 保存当前周期的高低价格，用于下一周期创建历史VP
                vp_last_profile_low := profile_low_price
                vp_last_profile_high := profile_high_price

                // 存储历史VPOC
                if vp_show_poc and not na(poc_price)
                    array.unshift(vp_historical_pocs, line.new(vp_last_time_profile_start, poc_price, time, poc_price, 
                                      xloc = xloc.bar_time, color = vp_poc_color, width = 1, style=DEFAULT_LINE_STYLE))
                    // 限制历史VPOC数量
                    if array.size(vp_historical_pocs) > max_historical_profiles * 3
                        line.delete(array.pop(vp_historical_pocs))

                // Clean up current VPOC drawings from previous period (if any) using pool
                if not na(vp_current_poc_main_line)
                    return_line_to_pool(vp_current_poc_main_line)
                    vp_current_poc_main_line := na
                if not na(vp_current_poc_label_line)
                    return_line_to_pool(vp_current_poc_label_line)
                    vp_current_poc_label_line := na
                if not na(vp_current_poc_label)
                    return_label_to_pool(vp_current_poc_label)
                    vp_current_poc_label := na
            
            else if barstate.islast and vp_show_poc // Update current VPOC line and label on last bar
                if na(vp_current_poc_main_line) // First time drawing on last bar or after reset
                    vp_current_poc_main_line := get_line_from_pool()
                    vp_current_poc_label_line := get_line_from_pool()
                    vp_current_poc_label := get_label_from_pool()

                // Update main POC line (from profile start to current bar)
                vp_current_poc_main_line.set_xy1(vp_last_time_profile_start, poc_price)
                vp_current_poc_main_line.set_xy2(time, poc_price)
                vp_current_poc_main_line.set_color(vp_poc_color)
                vp_current_poc_main_line.set_width(1)
                vp_current_poc_main_line.set_style(DEFAULT_LINE_STYLE)
                
                // Update POC label line (short segment at current bar)
                vp_current_poc_label_line.set_xy1(bar_index, poc_price)
                vp_current_poc_label_line.set_xy2(bar_index + vp_label_offset_bars, poc_price)
                vp_current_poc_label_line.set_color(vp_poc_color)
                vp_current_poc_label_line.set_width(1)
                vp_current_poc_label_line.set_style(DEFAULT_LINE_STYLE)
                //vp_current_poc_label_line.set_xloc(xloc.bar_index)

                // Update POC label
                vp_current_poc_label.set_xy(bar_index + vp_label_offset_bars, poc_price)
                vp_current_poc_label.set_text("POC")
                vp_current_poc_label.set_tooltip(str.tostring(poc_price, vp_price_format))
                vp_current_poc_label.set_color(color.new(vp_poc_color, 80)) // Semi-transparent background
                vp_current_poc_label.set_textcolor(color.white) // Contrasting text
                vp_current_poc_label.set_style(label.style_label_left)
                //vp_current_poc_label.set_xloc(xloc.bar_index)

// Update Volume Profile anchor points
if vp_enable
    if timeframe.change(vp_profile_tf) or na(vp_last_bar_idx_profile_start) // Also initialize on first run
        vp_last_bar_idx_profile_start := bar_index
        vp_last_time_profile_start := time

        // When profile TF changes, clear the current POC line/label from the previous profile period
        if not na(vp_current_poc_main_line)
            return_line_to_pool(vp_current_poc_main_line)
            vp_current_poc_main_line := na
        if not na(vp_current_poc_label_line)
            return_line_to_pool(vp_current_poc_label_line)
            vp_current_poc_label_line := na
        if not na(vp_current_poc_label)
            return_label_to_pool(vp_current_poc_label)
            vp_current_poc_label := na
            
        // 同时清理Value Area对象
        if not na(vp_current_value_area_polyline)
            vp_current_value_area_polyline.delete()
            vp_current_value_area_polyline := na
            
        // 重置Value Area索引
        vp_value_area_low_idx := na
        vp_value_area_high_idx := na
        
        // 清空Value Area点阵列
        array.clear(vp_value_area_points_array)


// =============================================================================
// ==== PLOTTING ====
// =============================================================================

plot(show_7d ? rvwap_7d : na, title='7D RVWAP', color=color_7d, linewidth=1)
plot(show_30d ? rvwap_30d : na, title='30D RVWAP', color=color_30d, linewidth=1)
plot(show_90d ? rvwap_90d : na, title='90D RVWAP', color=color_90d, linewidth=1)
plot(show_365d ? rvwap_365d : na, title='365D RVWAP', color=color_365d, linewidth=1)

vwap_plot1 = plot(VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? vwap1 : na, title='VWAP 1', color=VWAP1_Col, linewidth=1)
lowerBand_1 = plot(VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? band1_lower : na, title='L Band 1', color=Bands1_Col, linewidth=1)
upperBand_1 = plot(VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? band1_upper : na, title='U Band 1', color=Bands1_Col, linewidth=1)
fill(upperBand_1, lowerBand_1, color=VWAP1_Bgc, title='Fill 1')

vwap_plot2 = plot(VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? vwap2 : na, title='VWAP 2', color=VWAP2_Col, linewidth=1)
lowerBand_2 = plot(VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? band2_lower : na, title='L Band 2', color=Bands2_Col, linewidth=1)
upperBand_2 = plot(VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? band2_upper : na, title='U Band 2', color=Bands2_Col, linewidth=1)
fill(upperBand_2, lowerBand_2, color=VWAP2_Bgc, title='Fill 2')

vwap_plot3 = plot(VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? vwap3 : na, title='VWAP 3', color=VWAP3_Col, linewidth=1)
lowerBand_3 = plot(VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? band3_lower : na, title='L Band 3', color=Bands3_Col, linewidth=1)
upperBand_3 = plot(VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? band3_upper : na, title='U Band 3', color=Bands3_Col, linewidth=1)
fill(upperBand_3, lowerBand_3, color=VWAP3_Bgc, title='Fill 3')

vwap_plot4 = plot(VWAP4_Ctl and not is_4h_or_higher_tf ? vwap4 : na, title='VWAP 4', color=VWAP4_Col, linewidth=1)
lowerBand_4 = plot(VWAP4_Ctl and not is_4h_or_higher_tf ? band4_lower : na, title='L Band 4', color=Bands4_Col, linewidth=1)
upperBand_4 = plot(VWAP4_Ctl and not is_4h_or_higher_tf ? band4_upper : na, title='U Band 4', color=Bands4_Col, linewidth=1)
fill(upperBand_4, lowerBand_4, color=VWAP4_Bgc, title='Fill 4')

vwap_plot5 = plot(VWAP5_Ctl ? vwap5 : na, title='VWAP 5', color=VWAP5_Col, linewidth=1)
lowerBand_5 = plot(VWAP5_Ctl ? band5_lower : na, title='L Band 5', color=Bands5_Col, linewidth=1)
upperBand_5 = plot(VWAP5_Ctl ? band5_upper : na, title='U Band 5', color=Bands5_Col, linewidth=1)
fill(upperBand_5, lowerBand_5, color=VWAP5_Bgc, title='Fill 5')


if barstate.islast 
    bool force_clean_labels = true 
    bool labels_need_update_flag = false
    
    if na(cache_yearlyOpen) or na(cache_monthlyOpen) or na(cache_weeklyOpen) or na(cache_quarterlyOpen) or na(cache_dailyOpen) or na(cache_lastWeeklyPOC) or na(cache_lastMonthlyPOC) or na(cache_lastQuarterlyPOC) or na(cache_lastYearlyPOC) or yearlyOpen != cache_yearlyOpen or monthlyOpen != cache_monthlyOpen or weeklyOpen != cache_weeklyOpen or quarterlyOpen != cache_quarterlyOpen or dailyOpen != cache_dailyOpen or lastWeeklyPOC != cache_lastWeeklyPOC or lastMonthlyPOC != cache_lastMonthlyPOC or lastQuarterlyPOC != cache_lastQuarterlyPOC or lastYearlyPOC != cache_lastYearlyPOC
        labels_need_update_flag := true
    
    if labels_need_update_flag or force_clean_labels
        if array.size(key_open_labels) > 0 
            for i = 0 to array.size(key_open_labels) - 1
                label lbl_to_return = array.get(key_open_labels, i)
                return_label_to_pool(lbl_to_return)
            array.clear(key_open_labels) 
        if array.size(key_open_lines) > 0
            for i = 0 to array.size(key_open_lines) - 1
                line line_to_return = array.get(key_open_lines, i)
                return_line_to_pool(line_to_return)
            array.clear(key_open_lines) 
            
        if array.size(pvwap_labels) > 0
            for i = 0 to array.size(pvwap_labels) - 1
                label lbl_to_return = array.get(pvwap_labels, i)
                return_label_to_pool(lbl_to_return)
            array.clear(pvwap_labels) 
        if array.size(pvwap_lines) > 0
            for i = 0 to array.size(pvwap_lines) - 1
                line line_to_return = array.get(pvwap_lines, i)
                return_line_to_pool(line_to_return)
            array.clear(pvwap_lines) 
        
        if show_pvwap_yearly and not na(lastYearlyPOC) and not na(thisYearStart)
            plot_previous_vwap_levels('Year', lastYearlyUpper, lastYearlyLower, lastYearlyPOC, thisYearStart, color_pvwap_yearly)
        if show_pvwap_quarterly and not na(lastQuarterlyPOC) and not na(thisQuarterStart) and not is_monthly_or_higher_tf
            plot_previous_vwap_levels('Quarter', lastQuarterlyUpper, lastQuarterlyLower, lastQuarterlyPOC, thisQuarterStart, color_pvwap_quarterly)
        if show_pvwap_monthly and not na(lastMonthlyPOC) and not na(thisMonthStart) and not is_weekly_or_higher_tf
            plot_previous_vwap_levels('Month', lastMonthlyUpper, lastMonthlyLower, lastMonthlyPOC, thisMonthStart, color_pvwap_monthly)
        if show_pvwap_weekly and not na(lastWeeklyPOC) and not na(thisWeekStart) and not is_12h_or_higher_tf
            plot_previous_vwap_levels('Week', lastWeeklyUpper, lastWeeklyLower, lastWeeklyPOC, thisWeekStart, color_pvwap_weekly)
        
        if not use_tf_consistent_pvwap 
            if VWAP1_Ctl and Anchor1 == 'Quarter' and not is_monthly_or_higher_tf
                plot_previous_vwap_levels(Anchor1, lastQuarterlyUpper, lastQuarterlyLower, lastQuarterlyPOC, thisQuarterStart, VWAP1_Col)
            if VWAP2_Ctl and Anchor2 == 'Month' and not is_weekly_or_higher_tf
                plot_previous_vwap_levels(Anchor2, lastMonthlyUpper, lastMonthlyLower, lastMonthlyPOC, thisMonthStart, VWAP2_Col)
            if VWAP3_Ctl and Anchor3 == 'Week' and not is_12h_or_higher_tf
                plot_previous_vwap_levels(Anchor3, lastWeeklyUpper, lastWeeklyLower, lastWeeklyPOC, thisWeekStart, VWAP3_Col)
            if VWAP5_Ctl and Anchor5 == 'Year'
                plot_previous_vwap_levels(Anchor5, lastYearlyUpper, lastYearlyLower, lastYearlyPOC, thisYearStart, VWAP5_Col)

        if show_MonthlyOpen
            plot_key_open_level(monthlyOpen, "MO", color_MonthlyOpen, keylevel_offset, keylevel_format)
        if show_YearlyOpen
            plot_key_open_level(yearlyOpen, "YO", color_YearlyOpen, keylevel_offset, keylevel_format)
        if show_WeeklyOpen
            plot_key_open_level(weeklyOpen, "WO", color_WeeklyOpen, keylevel_offset, keylevel_format)
        if show_QuarterlyOpen
            plot_key_open_level(quarterlyOpen, "QO", color_QuarterlyOpen, keylevel_offset, keylevel_format)
        if show_DailyOpen
            plot_key_open_level(dailyOpen, "DO", color_DailyOpen, keylevel_offset, keylevel_format)
            
        cache_yearlyOpen := yearlyOpen
        cache_monthlyOpen := monthlyOpen
        cache_weeklyOpen := weeklyOpen
        cache_quarterlyOpen := quarterlyOpen
        cache_dailyOpen := dailyOpen
        cache_lastWeeklyPOC := lastWeeklyPOC
        cache_lastMonthlyPOC := lastMonthlyPOC
        cache_lastQuarterlyPOC := lastQuarterlyPOC
        cache_lastYearlyPOC := lastYearlyPOC

// ---- Plot Monday Range Lines ----
var line prevMonHighLine = na
var line prevMonLowLine = na
var bool prevMondayLinesDrawn = false // State for previous Monday lines

var line currMonHighLine = na
var line currMonLowLine = na
var float lastPlottedMondayHigh = na // Store last plotted value
var float lastPlottedMondayLow = na  // Store last plotted value
var int lastPlottedMondayStartTime = na // Store last plotted start time
var bool currentMondayLinesActive = false // State for current Monday lines

// Manage Previous Monday lines
if isNewWeek or (prevMondayLinesDrawn and not show_MondayRange)
    if not na(prevMonHighLine)
        return_line_to_pool(prevMonHighLine)
        prevMonHighLine := na
    if not na(prevMonLowLine)
        return_line_to_pool(prevMonLowLine)
        prevMonLowLine := na
    prevMondayLinesDrawn := false

if show_MondayRange and isNewWeek and not na(prevMondayHigh) and not na(prevMondayStartBar) and not na(prevWeekEndBar)
    int safe_prev_monday_start = na
    if not na(prevMondayStartBar) and bar_index - prevMondayStartBar >= 0
        safe_prev_monday_start := math.min(4900, math.max(0, bar_index - prevMondayStartBar))
    
    int safe_prev_week_end = na
    if not na(prevWeekEndBar) and bar_index - prevWeekEndBar >= 0
        safe_prev_week_end := math.min(4900, math.max(0, bar_index - prevWeekEndBar))
    
    if not na(safe_prev_monday_start) and not na(safe_prev_week_end)
        prevMondayStartTime := time[safe_prev_monday_start]
        prevWeekEndTime := time[safe_prev_week_end]
    
        if not na(prevMondayStartTime) and not na(prevWeekEndTime)
            prevMonHighLine := get_line_from_pool()
            prevMonHighLine.set_xy1(x=prevMondayStartTime, y=prevMondayHigh)
            prevMonHighLine.set_xy2(x=prevWeekEndTime, y=prevMondayHigh)
            prevMonHighLine.set_color(color=color_PrevMonday)
            prevMonHighLine.set_width(width=1)
            prevMonHighLine.set_style(style=line.style_dotted)
            
            prevMonLowLine := get_line_from_pool()
            prevMonLowLine.set_xy1(x=prevMondayStartTime, y=prevMondayLow)
            prevMonLowLine.set_xy2(x=prevWeekEndTime, y=prevMondayLow)
            prevMonLowLine.set_color(color=color_PrevMonday)
            prevMonLowLine.set_width(width=1)
            prevMonLowLine.set_style(style=line.style_dotted)
            prevMondayLinesDrawn := true

// Manage Current Monday lines
if isNewWeek and currentMondayLinesActive // Cleanup at the start of a new week
    if not na(currMonHighLine)
        return_line_to_pool(currMonHighLine)
        currMonHighLine := na
    if not na(currMonLowLine)
        return_line_to_pool(currMonLowLine)
        currMonLowLine := na
    lastPlottedMondayHigh := na
    lastPlottedMondayLow := na
    lastPlottedMondayStartTime := na
    currentMondayLinesActive := false

if barstate.islast
    if show_MondayRange and not na(mondayHigh) and not na(mondayLow) and not na(mondayStartBar)
        int mondayStartTimeValue = na
        int safe_monday_start_idx = na
        if bar_index - mondayStartBar >= 0
            safe_monday_start_idx := math.min(4900, math.max(0, bar_index - mondayStartBar))
            mondayStartTimeValue := time[safe_monday_start_idx]

        if not na(mondayStartTimeValue)
            if not currentMondayLinesActive // Create lines
                currMonHighLine := get_line_from_pool()
                currMonLowLine := get_line_from_pool()
                
                currMonHighLine.set_xy1(x=mondayStartTimeValue, y=mondayHigh)
                currMonHighLine.set_xy2(x=time, y=mondayHigh)
                currMonHighLine.set_color(color=color_CurrMonday)
                currMonHighLine.set_width(width=1)
                currMonHighLine.set_style(style=line.style_dotted)
                
                currMonLowLine.set_xy1(x=mondayStartTimeValue, y=mondayLow)
                currMonLowLine.set_xy2(x=time, y=mondayLow)
                currMonLowLine.set_color(color=color_CurrMonday)
                currMonLowLine.set_width(width=1)
                currMonLowLine.set_style(style=line.style_dotted)
                
                lastPlottedMondayHigh := mondayHigh
                lastPlottedMondayLow := mondayLow
                lastPlottedMondayStartTime := mondayStartTimeValue
                currentMondayLinesActive := true
            else // Lines exist, update them
                bool needsYUpdate = lastPlottedMondayHigh != mondayHigh or lastPlottedMondayLow != mondayLow
                bool needsX1Update = lastPlottedMondayStartTime != mondayStartTimeValue
                
                if needsX1Update
                    currMonHighLine.set_x1(x=mondayStartTimeValue)
                    currMonLowLine.set_x1(x=mondayStartTimeValue)
                    lastPlottedMondayStartTime := mondayStartTimeValue
                
                if needsYUpdate
                    currMonHighLine.set_y1(y=mondayHigh)
                    currMonHighLine.set_y2(y=mondayHigh)
                    currMonLowLine.set_y1(y=mondayLow)
                    currMonLowLine.set_y2(y=mondayLow)
                    lastPlottedMondayHigh := mondayHigh
                    lastPlottedMondayLow := mondayLow
                
                currMonHighLine.set_x2(x=time)
                currMonLowLine.set_x2(x=time)

    else if currentMondayLinesActive // show_MondayRange is false or not Monday anymore
        if not na(currMonHighLine)
            return_line_to_pool(currMonHighLine)
            currMonHighLine := na
        if not na(currMonLowLine)
            return_line_to_pool(currMonLowLine)
            currMonLowLine := na
        lastPlottedMondayHigh := na
        lastPlottedMondayLow := na
        lastPlottedMondayStartTime := na
        currentMondayLinesActive := false

// END OF SCRIPT
