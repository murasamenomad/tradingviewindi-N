// @version=6
indicator(title='N', shorttitle='N', overlay=true, max_bars_back=4999, max_polylines_count=100, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// Import Professional Calculation Library
import PineCoders/ConditionalAverages/1 as pc

// =============================================================================
// ==== INPUTS ====
// =============================================================================

// Constants
var string FONT_MONO = font.family_monospace
var DEFAULT_LINE_STYLE = line.style_dotted
var PVWAP_LINE_STYLE = line.style_solid // Added new constant for pvwap and key level lines
var DEFAULT_LABEL_STYLE = label.style_label_left
var int KEYLEVEL_LINE_LENGTH = 3

// ==== Rolling VWAP Settings ====
group_rvwap = 'æ»šåŠ¨VWAPè®¾ç½® (Rolling VWAP)'
show_7d = input.bool(true, 'æ˜¾ç¤º7å¤© (Show 7D)', group=group_rvwap)
show_30d = input.bool(true, 'æ˜¾ç¤º30å¤© (Show 30D)', group=group_rvwap)
show_90d = input.bool(true, 'æ˜¾ç¤º90å¤© (Show 90D)', group=group_rvwap)
show_365d = input.bool(true, 'æ˜¾ç¤º365å¤© (Show 365D)', group=group_rvwap)
color_7d = input.color(color.new(#6BEFF9, 20), '7Dé¢œè‰² (Color)', group=group_rvwap, inline='7d')
color_30d = input.color(color.new(#00BED6, 20), '30Dé¢œè‰² (Color)', group=group_rvwap, inline='30d')
color_90d = input.color(color.new(#006C7A, 0), '90Dé¢œè‰² (Color)', group=group_rvwap, inline='90d')
color_365d = input.color(color.new(#004851, 0), '365Dé¢œè‰² (Color)', group=group_rvwap, inline='365d')
rvwap_ref_tf = input.string('60', 'å‚è€ƒæ—¶é—´æ¡†æ¶ (Reference TF)', options=['5', '15', '60', '240', 'D'], group=group_rvwap, tooltip='ç”¨äºè®¡ç®—æ»šåŠ¨VWAPçš„å‚è€ƒæ—¶é—´æ¡†æ¶')
rvwap_smoothing = input.int(1, 'å¹³æ»‘å‘¨æœŸ (Smoothing)', minval=1, maxval=100, group=group_rvwap, tooltip='æ»šåŠ¨VWAPçš„å¹³æ»‘å‘¨æœŸæ•°')
show_rvwap_label_7d = input.bool(true, 'æ˜¾ç¤º7Dæ ‡ç­¾ (Show 7D Label)', group=group_rvwap, inline='rvwap_7d_label')
show_rvwap_label_30d = input.bool(true, 'æ˜¾ç¤º30Dæ ‡ç­¾ (Show 30D Label)', group=group_rvwap, inline='rvwap_30d_label')
show_rvwap_label_90d = input.bool(true, 'æ˜¾ç¤º90Dæ ‡ç­¾ (Show 90D Label)', group=group_rvwap, inline='rvwap_90d_label')
show_rvwap_label_365d = input.bool(true, 'æ˜¾ç¤º365Dæ ‡ç­¾ (Show 365D Label)', group=group_rvwap, inline='rvwap_365d_label')
rvwap_label_offset = input.int(60, 'RVWAP æ ‡ç­¾åç§» (Label Offset)', minval=1, group=group_rvwap, tooltip='RVWAPæ ‡ç­¾çš„æ°´å¹³åç§»é‡ï¼Œå•ä½ä¸ºKçº¿æ•°é‡ã€‚')
rvwap_label_format = input.string('#.####', 'RVWAP ä»·æ ¼æ ¼å¼ (Price Format)', group=group_rvwap)

// ==== Anchored VWAP Settings ====
VWAP_Ctl_Group = 'é”šå®šVWAP (Anchored VWAP)'
master_AVWAP = input.bool(true, 'ğŸ”´ æ€»å¼€å…³ - Anchored VWAP', group=VWAP_Ctl_Group, inline='master')
vwapSource = hlc3

// --- VWAP #1 (Defaults to Quarterly) ---
VWAP1_Settings = 'VWAP #1 Settings (Quarterly Default)'
VWAP1_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
Anchor1 = input.string(defval='Quarter', title='', group=VWAP_Ctl_Group, inline=VWAP1_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP1_Col = input.color(color.new(#7E57C2, 50), title='POC', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
Bands1_Col = input.color(color.new(#7E57C2, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
VWAP1_Bgc = input.color(color.new(#7E57C2, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP1_Settings)

// --- VWAP #2 (Defaults to Monthly) ---
VWAP2_Settings = 'VWAP #2 Settings (Monthly Default)'
VWAP2_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
Anchor2 = input.string(defval='Month', title='', group=VWAP_Ctl_Group, inline=VWAP2_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP2_Col = input.color(color.new(#29B6F6, 50), title='POC', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
Bands2_Col = input.color(color.new(#29B6F6, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
VWAP2_Bgc = input.color(color.new(#29B6F6, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP2_Settings)

// --- VWAP #3 (Defaults to Weekly) ---
VWAP3_Settings = 'VWAP #3 Settings (Weekly Default)'
VWAP3_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
Anchor3 = input.string(defval='Week', title='', group=VWAP_Ctl_Group, inline=VWAP3_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP3_Col = input.color(color.new(#FFCA28, 50), title='POC', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
Bands3_Col = input.color(color.new(#FFCA28, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
VWAP3_Bgc = input.color(color.new(#FFCA28, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP3_Settings)

// --- VWAP #4 (Defaults to Daily) ---
VWAP4_Settings = 'VWAP #4 Settings (Daily Default)'
VWAP4_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
Anchor4 = input.string(defval='Day', title='', group=VWAP_Ctl_Group, inline=VWAP4_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP4_Col = input.color(color.new(#FFFFFF, 70), title='POC', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
Bands4_Col = input.color(color.new(#FFFFFF, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
VWAP4_Bgc = input.color(color.new(#FFFFFF, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP4_Settings)

// --- VWAP #5 (Defaults to Yearly) ---
VWAP5_Settings = 'VWAP #5 Settings (Yearly Default)'
VWAP5_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
Anchor5 = input.string(defval='Year', title='', group=VWAP_Ctl_Group, inline=VWAP5_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP5_Col = input.color(color.new(#BDBDBD, 10), title='POC', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
Bands5_Col = input.color(color.new(#BDBDBD, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
VWAP5_Bgc = input.color(color.new(#BDBDBD, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP5_Settings)

// ==== Previous Period VWAP Settings ====
VWAP_KeyLevel_Grp = 'å‰æœŸVWAPå…³é”®æ°´å¹³ (Previous VWAP Key Level)'
use_adaptive_tf = input.bool(true, 'ä½¿ç”¨è‡ªé€‚åº”æ—¶é—´æ¡†æ¶ (Use Adaptive TF)', group=VWAP_KeyLevel_Grp, tooltip="æ ¹æ®å½“å‰å›¾è¡¨æ—¶é—´æ¡†æ¶è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„é”šå®šæ—¶é—´æ¡†æ¶è¿›è¡Œè®¡ç®—")
use_tf_consistent_pvwap = input.bool(true, 'ä½¿ç”¨è·¨æ—¶é—´æ¡†æ¶pVWAP (TF-Consistent pVWAP)', group=VWAP_KeyLevel_Grp, tooltip="ä½¿ç”¨ä¸€è‡´çš„è®¡ç®—æ–¹æ³•åœ¨æ‰€æœ‰æ—¶é—´æ¡†æ¶ä¸‹æ˜¾ç¤ºä¸€è‡´çš„pVWAPå€¼")
show_pvwap_yearly = input.bool(true, "æ˜¾ç¤ºå‰æœŸå¹´åº¦VWAP (Show Previous Yearly VWAP)", group=VWAP_KeyLevel_Grp, inline="pyVWAP")
color_pvwap_yearly = input.color(color.new(#BDBDBD, 30), "", group=VWAP_KeyLevel_Grp, inline="pyVWAP")
show_pvwap_quarterly = input.bool(true, "æ˜¾ç¤ºå‰æœŸå­£åº¦VWAP (Show Previous Quarterly VWAP)", group=VWAP_KeyLevel_Grp, inline="pqVWAP")
color_pvwap_quarterly = input.color(color.new(#7E57C2, 30), "", group=VWAP_KeyLevel_Grp, inline="pqVWAP")
show_pvwap_monthly = input.bool(true, "æ˜¾ç¤ºå‰æœŸæœˆåº¦VWAP (Show Previous Monthly VWAP)", group=VWAP_KeyLevel_Grp, inline="pmVWAP")
color_pvwap_monthly = input.color(color.new(#29B6F6, 30), "", group=VWAP_KeyLevel_Grp, inline="pmVWAP")
show_pvwap_weekly = input.bool(true, "æ˜¾ç¤ºå‰æœŸå‘¨åº¦VWAP (Show Previous Weekly VWAP)", group=VWAP_KeyLevel_Grp, inline="pwVWAP")
color_pvwap_weekly = input.color(color.new(#FFCA28, 30), "", group=VWAP_KeyLevel_Grp, inline="pwVWAP")
label_color_setting = input.color(color.new(color.yellow, 100), 'pVWAP æ ‡ç­¾èƒŒæ™¯ (Label BG)', group=VWAP_KeyLevel_Grp)
pvwap_offset = input.int(20, 'pVWAP æ ‡ç­¾åç§» (Label Offset)', minval=1, group=VWAP_KeyLevel_Grp)
pvwap_format_level = input.string('#.####', 'pVWAP ä»·æ ¼æ ¼å¼ (Price Format)', group=VWAP_KeyLevel_Grp)

// ==== Key Open Level Settings ====
KeyOpen_Grp = 'å…³é”®å¼€ç›˜ä»· (Key Open Levels)'
keylevel_offset = input.int(50, 'å¼€ç›˜ä»· æ ‡ç­¾åç§» (Label Offset)', minval=1, group=KeyOpen_Grp, tooltip="Offset for Key Open labels, different from pVWAP offset.")
keylevel_format = input.string('#.####', 'å¼€ç›˜ä»· ä»·æ ¼æ ¼å¼ (Price Format)', group=KeyOpen_Grp)
use_ref_tf_for_opens = input.bool(true, 'ä½¿ç”¨æ—¥çº¿è®¡ç®—å…³é”®å¼€ç›˜ä»· (Use Daily for Key Opens)', group=KeyOpen_Grp, tooltip='å¼€å¯åå°†ä½¿ç”¨æ—¥çº¿æ•°æ®æ¥ç¡®ä¿åœ¨æ‰€æœ‰æ—¶é—´æ¡†æ¶ä¸‹å…³é”®å¼€ç›˜ä»·ä¿æŒä¸€è‡´')
show_MonthlyOpen = input.bool(true, "æœˆå¼€ç›˜ä»· (Monthly Open)", group=KeyOpen_Grp, inline="MO")
color_MonthlyOpen = input.color(color.new(#29B6F6, 30), "", group=KeyOpen_Grp, inline="MO")
show_YearlyOpen = input.bool(true, "å¹´å¼€ç›˜ä»· (Yearly Open)", group=KeyOpen_Grp, inline="YO")
color_YearlyOpen = input.color(color.new(#BDBDBD, 30), "", group=KeyOpen_Grp, inline="YO")
show_WeeklyOpen = input.bool(true, "å‘¨å¼€ç›˜ä»· (Weekly Open)", group=KeyOpen_Grp, inline="WO")
color_WeeklyOpen = input.color(color.new(#FFCA28, 30), "", group=KeyOpen_Grp, inline="WO")
show_QuarterlyOpen = input.bool(true, "å­£å¼€ç›˜ä»· (Quarterly Open)", group=KeyOpen_Grp, inline="QO")
color_QuarterlyOpen = input.color(color.new(#7E57C2, 30), "", group=KeyOpen_Grp, inline="QO")
show_DailyOpen = input.bool(true, "æ—¥å¼€ç›˜ä»· (Daily Open)", group=KeyOpen_Grp, inline="DO")
color_DailyOpen = input.color(color.new(#FFFFFF, 30), "", group=KeyOpen_Grp, inline="DO")

// ==== Monday Range Settings ====
MondayRange_Grp = 'å‘¨ä¸€åŒºé—´ (Monday Range)'
show_MondayRange = input.bool(true, "æ˜¾ç¤ºå‘¨ä¸€åŒºé—´ (Show Monday Range)", group=MondayRange_Grp)
color_PrevMonday = input.color(color.new(#757575, 30), "ä¸Šå‘¨é¢œè‰² (Prev Week Color)", group=MondayRange_Grp, inline="MR1")
color_CurrMonday = input.color(color.new(#757575, 30), "æœ¬å‘¨é¢œè‰² (Curr Week Color)", group=MondayRange_Grp, inline="MR2")

// ==== Volume Profile Settings ====
group_vp = 'æˆäº¤é‡åˆ†å¸ƒå›¾ (Volume Profile)'
vp_enable = input.bool(true, 'å¯ç”¨VP (Enable VP)', group = group_vp)
vp_show_profile = input.bool(true, 'æ˜¾ç¤ºVPæŸ±çŠ¶å›¾ (Show VP Histogram)', inline = 'VP_Display', tooltip = 'æ˜¯å¦æ˜¾ç¤ºæˆäº¤é‡åˆ†å¸ƒå›¾çš„æŸ±çŠ¶å›¾', group = group_vp)
vp_profile_color = input.color(color.new(#757575, 90), '', inline = 'VP_Display', group = group_vp)
vp_show_historical = input.bool(true, 'æ˜¾ç¤ºå†å²VP (Show Historical VP)', inline = 'VP_History', tooltip = 'æ˜¯å¦æ˜¾ç¤ºå†å²æˆäº¤é‡åˆ†å¸ƒå›¾', group = group_vp)
vp_historical_color = input.color(color.new(#757575, 90), '', inline = 'VP_History', group = group_vp)
// Value Areaå›ºå®šé¢œè‰²è®¾ç½®ä¸º#78909Cï¼Œä¸é€æ˜åº¦20%
vp_value_area_color = color.new(#757575, 80)
vp_max_history = input.int(7, 'å†å²VPæ•°é‡ (Max History)', 1, 10, tooltip = 'æœ€å¤§ä¿å­˜çš„å†å²VPæ•°é‡', group = group_vp)
vp_show_poc = input.bool(true, 'æ˜¾ç¤ºVPOC (Show VPOC)', inline = 'VPOC_Display', tooltip = 'æ˜¯å¦æ˜¾ç¤ºæˆäº¤é‡æ§åˆ¶ç‚¹ (VPOC)', group = group_vp)
vp_poc_color = input.color(color.new(#00BCD4, 0), '', inline = 'VPOC_Display', group = group_vp)
vp_rows = input.int(200, 'è¡Œæ•° (Rows)', 10, 500, tooltip = 'ç”¨äºæ„å»ºæˆäº¤é‡åˆ†å¸ƒå›¾çš„ä»·æ ¼çº§åˆ«/è¡Œæ•°', group = group_vp)
vp_profile_tf = input.timeframe('W', 'åˆ†å¸ƒå›¾æ—¶é—´æ¡†æ¶ (Profile Timeframe)', tooltip = 'æˆäº¤é‡åˆ†å¸ƒå›¾æ‰€ä»£è¡¨çš„èšåˆæ—¶é—´æ¡†æ¶', group = group_vp)
vp_resolution_tf = input.timeframe('3', 'è§£æåº¦æ—¶é—´æ¡†æ¶ (Resolution Timeframe)', tooltip = 'ç”¨äºæ„å»ºæˆäº¤é‡åˆ†å¸ƒå›¾çš„æ›´ä½çº§åˆ«æ—¶é—´æ¡†æ¶æ•°æ®', group = group_vp)
vp_extend_profile_percent = input.int(30, 'åˆ†å¸ƒå›¾å»¶ä¼¸ % (Profile Extend %)', 0, 100, tooltip = 'æˆäº¤é‡åˆ†å¸ƒå›¾åº”å»¶ä¼¸åˆ°ä¸‹ä¸€ä¸ªå‘¨æœŸçš„ç™¾åˆ†æ¯”', group = group_vp)
vp_label_offset_bars = input.int(5, 'VPOCæ ‡ç­¾åç§»æŸ±æ•° (VPOC Label Offset Bars)', 1, 100, group = group_vp, tooltip = 'å½“å‰VPOCæ ‡ç­¾çš„æŸ±åç§»é‡')
vp_price_format = input.string('#.##', 'VPOCä»·æ ¼æ ¼å¼ (VPOC Price Format)', group = group_vp)

// ==== Market Order Bubble Settings ====
group_mob = 'å¸‚ä»·å•æ°”æ³¡ (Market Order Bubbles)'
enable_mob = input.bool(true, "å¯ç”¨å¸‚ä»·å•æ°”æ³¡ (Enable MOB)", group = group_mob)
i_useCustomTf = input.bool(true, "Use Custom Lower Timeframe", group = group_mob, tooltip = "If unchecked, the script will automatically select a lower timeframe.")
i_lowerTf = input.timeframe("1", "Lower Timeframe for Delta Calc", group = group_mob, tooltip = "The timeframe used to estimate volume delta.")
i_statLookback = input.int(100, "Statistical Lookback Period", minval = 20, maxval = 200, group = group_mob, tooltip = "Bars for calculating average and standard deviation.")
i_zscoreThreshold = input.float(3.5, "Z-Score Threshold", minval = 0.5, step = 0.1, group = group_mob, tooltip = "Z-Score threshold for bubble detection.")
i_maxBubbles = input.int(100, "Max Bubbles to Display", minval = 1, maxval = 500, group = group_mob, tooltip = "Maximum bubbles to keep on chart.")
i_buyBubbleColor = input.color(color.green, "Buy Bubble Base Color", group = group_mob, tooltip = "Base color for buy bubbles.")
i_sellBubbleColor = input.color(color.red, "Sell Bubble Base Color", group = group_mob, tooltip = "Base color for sell bubbles.")
i_showBubbleText = input.bool(true, "Show Bubble Text", group = group_mob, tooltip = "Show delta value text inside bubbles.")
i_useDynamicSize = input.bool(true, "Use Dynamic Bubble Size", group = group_mob, tooltip = "Adjust bubble size based on Z-Score.")
i_useDynamicTransparency = input.bool(true, "Use Dynamic Transparency", group = group_mob, tooltip = "Adjust transparency based on Z-Score.")
i_filterTimeframe = input.bool(true, "Enable Timeframe Filter (<= 15min)", group = group_mob)
i_filterDate = input.bool(true, "Enable Date Filter (Last 3 Days)", group = group_mob)
i_daysToShow = input.int(3, "Days to Show", minval = 1, group = group_mob)

// ==== å¼‚å¸¸æˆäº¤é‡ä¸Kçº¿å†…éƒ¨å‰–æ (Abnormal Volume & Intrabar Profile) ====
group_avp = "å¼‚å¸¸æˆäº¤é‡ä¸å‰–æ (Abnormal Vol & Profile)"
avp_ma_period = input.int(30, "æˆäº¤é‡MAå‘¨æœŸ (Volume MA Period)", minval=10, maxval=100, group=group_avp)
avp_vol_multiplier = input.float(2.5, "æˆäº¤é‡ä¹˜æ•° (Volume Multiplier)", minval=1.5, maxval=5.0, step=0.1, group=group_avp)
avp_ltf_timeframe = input.timeframe("1", "å‰–æç”¨å°å‘¨æœŸ (Lower Timeframe for Profile)", group=group_avp)
avp_profile_rows = input.int(100, "å‰–æè¡Œæ•° (Profile Rows)", minval=5, maxval=100, group=group_avp)
avp_abnormal_bull_color = input.color(color.new(color.blue, 0), "å¼‚å¸¸çœ‹æ¶¨Kçº¿é¢œè‰² (Abnormal Bullish Bar Color)", group=group_avp)
avp_abnormal_bear_color = input.color(color.new(color.red, 0), "å¼‚å¸¸çœ‹è·ŒKçº¿é¢œè‰² (Abnormal Bearish Bar Color)", group=group_avp)
avp_pos_delta_color = input.color(color.new(color.blue, 0), "æ­£Deltaé¢œè‰² (Positive Delta Color)", group=group_avp)
avp_neg_delta_color = input.color(color.new(color.red, 0), "è´ŸDeltaé¢œè‰² (Negative Delta Color)", group=group_avp)
avp_vpoc_line_width = input.int(2, "VPOCçº¿å®½ (VPOC Line Width)", minval=1, group=group_avp)
// æ–°å¢: ä¸ºAVPçº¿æ¡æ·»åŠ æ•°é‡ä¸Šé™æ§åˆ¶ï¼Œä»¥é˜²æ­¢ç»˜å›¾å¯¹è±¡æ³„æ¼
avp_max_lines = input.int(50, "æœ€å¤§AVPçº¿æ¡æ•° (Max AVP Lines)", minval=1, maxval=200, group=group_avp, tooltip="å›¾è¡¨ä¸Šä¿ç•™çš„å¼‚å¸¸æˆäº¤é‡VPOCçº¿æ¡çš„æœ€å¤§æ•°é‡ã€‚è¿™æœ‰åŠ©äºé˜²æ­¢ç»˜å›¾å¯¹è±¡è¿‡å¤šå¯¼è‡´çš„é—®é¢˜ã€‚")

// =============================================================================
// ==== GLOBAL VARIABLE DECLARATIONS ====
// =============================================================================

var int cached_day = na
var int cached_month = na
var int cached_year = na
var int cached_quarter = na
var int cached_dayofweek = na

// Abnormal Volume & Profile Global Variables
var array<float> avp_ltf_high = array.new_float()
var array<float> avp_ltf_low = array.new_float()
var array<float> avp_ltf_close = array.new_float()
var array<float> avp_ltf_open = array.new_float()
var array<float> avp_ltf_volume = array.new_float()
// æ–°å¢: ä¸ºAVPçº¿æ¡åˆ›å»ºä¸“å±ç®¡ç†æ•°ç»„
var array<line> avp_lines = array.new_line()

// Market Order Bubble Global Variables
var array<label> text_pool = array.new_label()   // æ–‡å­—çš„å¯¹è±¡æ± 
var int text_pointer = 0                        // æ–‡å­—çš„æŒ‡é’ˆ

// Initialize the text pool on the first bar
if barstate.isfirst
    // åˆå§‹åŒ–æ–‡å­—æ± 
    for i = 0 to i_maxBubbles - 1
        array.push(text_pool, label.new(na, na, "", style=label.style_none, textcolor=color.white))

// æ·»åŠ åœ¨å…¨å±€å˜é‡å£°æ˜åŒºåŸŸ
var bool isNewWeekPeriod = false
var bool isNewMonthPeriod = false
var bool isNewQuarterPeriod = false
var bool isNewYearPeriod = false
var bool isNewDayPeriod = false

var line[] line_pool = array.new_line()
var label[] label_pool = array.new_label()
var bool[] line_used_map = array.new_bool()
var bool[] label_used_map = array.new_bool()

initialize_object_pools() => // Function to initialize object pools
    if array.size(line_pool) == 0
        for i = 0 to 199
            line_obj = line.new(x1=0, y1=0, x2=0, y2=0, color=color.white, width=1, xloc=xloc.bar_time, style=DEFAULT_LINE_STYLE)
            array.push(line_pool, line_obj)
            array.push(line_used_map, false)
    if array.size(label_pool) == 0
        for i = 0 to 199
            label_obj = label.new(x=0, y=0, text="", color=color.white, textcolor=color.black, style=DEFAULT_LABEL_STYLE, xloc=xloc.bar_time, text_font_family=FONT_MONO)
            array.push(label_pool, label_obj)
            array.push(label_used_map, false)

get_line_from_pool() => // Function to get a line object from the pool
    initialize_object_pools()
    line result = na
    int pool_size = array.size(line_pool)
    
    // Simplified single linear scan
    for i = 0 to pool_size - 1
        if not array.get(line_used_map, i)
            array.set(line_used_map, i, true)
            result := array.get(line_pool, i)
            break
            
    if na(result) // If pool is exhausted, create a new one
        new_line = line.new(x1=0, y1=0, x2=0, y2=0, color=color.white, width=1, xloc=xloc.bar_time, style=DEFAULT_LINE_STYLE)
        array.push(line_pool, new_line)
        array.push(line_used_map, true)
        result := new_line
    result

get_label_from_pool() => // Function to get a label object from the pool
    initialize_object_pools()
    label result = na
    int pool_size = array.size(label_pool)

    // Simplified single linear scan
    for i = 0 to pool_size - 1
        if not array.get(label_used_map, i)
            array.set(label_used_map, i, true)
            result := array.get(label_pool, i)
            break
            
    if na(result) // If pool is exhausted, create a new one
        new_label = label.new(x=0, y=0, text="", color=color.white, textcolor=color.black, style=DEFAULT_LABEL_STYLE, xloc=xloc.bar_time, text_font_family=FONT_MONO)
        array.push(label_pool, new_label)
        array.push(label_used_map, true)
        result := new_label
    result

return_line_to_pool(line_obj) => 
    bool _return = false 
    if not na(line_obj)
        int pool_size = array.size(line_pool)
        // ä¿®å¤ï¼šä½¿ç”¨æ­£åºæ‰«ææ›¿ä»£è´Ÿæ­¥é•¿
        for i = 0 to pool_size - 1
            if array.get(line_pool, i) == line_obj
                array.set(line_used_map, i, false)
                _return := true
                break
    _return


return_label_to_pool(label_obj) => 
    bool _return = false 
    if not na(label_obj)
        int pool_size = array.size(label_pool)
        // ä¿®å¤ï¼šä½¿ç”¨æ­£åºæ‰«ææ›¿ä»£è´Ÿæ­¥é•¿
        for i = 0 to pool_size - 1
            if array.get(label_pool, i) == label_obj
                array.set(label_used_map, i, false)
                _return := true
                break
    _return


var label[] key_open_labels = array.new_label()
var label[] pvwap_labels = array.new_label()
var line[] key_open_lines = array.new_line()
var line[] pvwap_lines = array.new_line()
var label[] rvwap_labels = array.new_label()
var line[] rvwap_lines = array.new_line()

var float cache_yearlyOpen = na
var float cache_monthlyOpen = na
var float cache_weeklyOpen = na
var float cache_quarterlyOpen = na
var float cache_dailyOpen = na
var float cache_lastWeeklyPOC = na
var float cache_lastMonthlyPOC = na
var float cache_lastQuarterlyPOC = na
var float cache_lastYearlyPOC = na
var float cache_rvwap_7d = na
var float cache_rvwap_30d = na
var float cache_rvwap_90d = na
var float cache_rvwap_365d = na

var int thisWeekStart = na
var float lastWeeklyLower = na
var float lastWeeklyUpper = na
var float lastWeeklyPOC = na
var int thisMonthStart = na
var float lastMonthlyLower = na
var float lastMonthlyUpper = na
var float lastMonthlyPOC = na
var int thisQuarterStart = na
var float lastQuarterlyLower = na
var float lastQuarterlyUpper = na
var float lastQuarterlyPOC = na
var int thisYearStart = na
var float lastYearlyLower = na
var float lastYearlyUpper = na
var float lastYearlyPOC = na

var float monthlyOpen = na
var float yearlyOpen = na
var float weeklyOpen = na
var float quarterlyOpen = na
var float dailyOpen = na

var float mondayHigh = na
var float mondayLow = na
var int mondayStartBar = na
var int mondayEndBar = na
var float prevMondayHigh = na
var float prevMondayLow = na
var int prevMondayStartBar = na
var int prevWeekEndBar = na

var int prevMondayStartTime = na  
var int prevWeekEndTime = na     

// Volume Profile Global Variables
var array<line> vp_historical_pocs = array.new_line() // Stores historical VPOC lines
var array<polyline> vp_historical_profiles = array.new<polyline>(0) // å­˜å‚¨å†å²VPå›¾å½¢
var array<polyline> vp_historical_value_areas = array.new<polyline>(0) // å­˜å‚¨å†å²VPçš„Value Area
var int max_historical_profiles = 5 // æœ€å¤§ä¿å­˜çš„å†å²VPå›¾å½¢æ•°é‡

// ã€ä¿®å¤ã€‘é¢„åˆ†é…æœ€å¤§å®¹é‡æ•°ç»„ï¼ˆ500è¡Œä¸Šé™ï¼‰ï¼Œé¿å…é‡å¤åˆ›å»º
MAX_VP_ROWS = 500
var float[] vp_volume_values = array.new_float(MAX_VP_ROWS, 0.0)
var float[] vp_y_coords = array.new_float(MAX_VP_ROWS, 0.0)
var int[] vp_x_coords = array.new_int(MAX_VP_ROWS, 0)

// ã€æ–°å¢ã€‘å®é™…ä½¿ç”¨çš„è¡Œæ•°ï¼ˆåŠ¨æ€æ§åˆ¶ï¼Œä¸è¶…è¿‡é¢„åˆ†é…å®¹é‡ï¼‰
var int vp_active_rows = 0

var array<chart.point> vp_profile_points_array = array.new<chart.point>() // Stores points for drawing the polyline
var array<chart.point> vp_value_area_points_array = array.new<chart.point>() // Stores points for drawing value area
var polyline vp_current_profile_polyline = na        // The current volume profile polyline
var polyline vp_current_value_area_polyline = na     // The current value area polyline
var line vp_current_poc_main_line = na            // Line for the current VPOC (from profile start to current bar)
var line vp_current_poc_label_line = na           // Short line segment for the current VPOC label
var label vp_current_poc_label = na               // Label for the current VPOC
var int vp_last_bar_idx_profile_start = na        // Bar index at the start of the current VP period
var int vp_last_time_profile_start = na           // Time at the start of the current VP period
var float vp_last_profile_low = na                // ä¿å­˜ä¸Šä¸€ä¸ªå‘¨æœŸçš„æœ€ä½ä»·æ ¼
var float vp_last_profile_high = na               // ä¿å­˜ä¸Šä¸€ä¸ªå‘¨æœŸçš„æœ€é«˜ä»·æ ¼
var int vp_value_area_low_idx = na                // Value Areaçš„ä¸‹ç•Œç´¢å¼•
var int vp_value_area_high_idx = na               // Value Areaçš„ä¸Šç•Œç´¢å¼•

// =============================================================================
// ==== BOUNDARY SAFE FUNCTIONS ====
// =============================================================================

// ã€æ ¸å¿ƒä¿®å¤ã€‘å®‰å…¨çš„æ•°ç»„æ“ä½œå‡½æ•°ï¼Œé˜²æ­¢è¶Šç•Œè®¿é—®
safe_set_volume(idx, value) =>
    bool success = false
    if idx >= 0 and idx < vp_active_rows
        array.set(vp_volume_values, idx, value)
        success := true
    success

safe_get_volume(idx) =>
    idx >= 0 and idx < vp_active_rows ? array.get(vp_volume_values, idx) : 0.0

safe_set_y_coord(idx, price) =>
    bool success = false
    if idx >= 0 and idx < vp_active_rows
        array.set(vp_y_coords, idx, price)
        success := true

safe_set_x_coord(idx, time_val) =>
    bool success = false
    if idx >= 0 and idx < vp_active_rows
        array.set(vp_x_coords, idx, time_val)
        success := true
    success

get_quarter(t) => // Function to get the quarter of a given time
    m = month(t)
    (m <= 3) ? 1 : (m <= 6) ? 2 : (m <= 9) ? 3 : 4

// =============================================================================
// ==== FUNCTIONS ====
// =============================================================================

// ==== Market Order Bubble Functions ====
// Function to automatically select a suitable lower timeframe based on the chart's timeframe.
f_autoLowerTf() =>
    string tf = ""
    if timeframe.isintraday
        if timeframe.multiplier <= 5
            tf := "1"
        else if timeframe.multiplier <= 15
            tf := "1"
        else if timeframe.multiplier <= 60
            tf := "5"
        else if timeframe.multiplier <= 240
            tf := "15"
        else
            tf := "60"
    else if timeframe.isdaily
        tf := "60"
    else if timeframe.isweekly
        tf := "240"
    else // Monthly
        tf := "D"
    tf

// Function to estimate Volume Delta using the superior intrabar analysis method.
f_getVolumeDelta(tf) =>
    // Request lower timeframe OHLCV data all at once
    [ltf_o, ltf_c, ltf_h, ltf_l, ltf_v] = request.security_lower_tf(syminfo.tickerid, tf, [open, close, high, low, volume])
    
    // Initialize buy and sell volume for the current bar.
    float buyVol = 0.0
    float sellVol = 0.0
    
    // Accumulate volume based on the direction of each intrabar.
    if array.size(ltf_c) > 0
        for i = 0 to array.size(ltf_c) - 1
            float intrabar_vol = array.get(ltf_v, i) // ç›´æ¥ä»æ•°ç»„è·å–æˆäº¤é‡
            float intrabar_o = array.get(ltf_o, i)
            float intrabar_c = array.get(ltf_c, i)
            
            if intrabar_c > intrabar_o
                buyVol += intrabar_vol
            else if intrabar_c < intrabar_o
                sellVol += intrabar_vol
            // If open equals close, volume is neutral and not counted.
    [buyVol, sellVol]

// Function to get dynamic transparency based on Z-Score
f_getBubbleTransparency(zscore) =>
    if not i_useDynamicTransparency
        75 // Default transparency
    else
        absZscore = math.abs(zscore)
        if absZscore < 3.9
            90 // Very transparent
        else if absZscore < 4.3
            70
        else if absZscore < 4.7
            90
        else if absZscore < 5.0
            70
        else
            90 // Very opaque (significant event)

detect_timeframe_changes() => // Function to detect timeframe changes
    current_day = dayofmonth(time)
    current_month = month(time)
    current_year = year(time)
    current_quarter = get_quarter(time)
    current_dayofweek = dayofweek(time)
    isNewDay = current_day != cached_day or current_month != cached_month
    isNewWeek = current_dayofweek == dayofweek.monday and cached_dayofweek != dayofweek.monday
    isNewMonth = current_month != cached_month
    isNewQuarter = current_quarter != cached_quarter
    isNewYear = current_year != cached_year
    [isNewDay, isNewWeek, isNewMonth, isNewQuarter, isNewYear, current_day, current_month, current_year, current_quarter, current_dayofweek]

get_adaptive_anchor_tf(vwap_type='default') => // Function to get adaptive anchor timeframe
    current_tf = timeframe.period
    if vwap_type == 'yearly' or vwap_type == 'pyvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15" or current_tf == "30" or current_tf == "45" or current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "60"
    else if vwap_type == 'quarterly' or vwap_type == 'pqvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15" or current_tf == "30" or current_tf == "45" or current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "45"
    else if vwap_type == 'monthly' or vwap_type == 'pmvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "30"
    else if vwap_type == 'weekly' or vwap_type == 'pwvwap'
        if current_tf == "1" or current_tf == "3"
            "3"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240" or current_tf == "D" or current_tf == "W"
            "240"
        else
            "15"
    else if vwap_type == 'daily'
        if current_tf == "1"
            "1"
        else if current_tf == "3"
            "3"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240" or current_tf == "D" or current_tf == "W" or current_tf == "M"
            "240"
        else
            "15"
    else // default
        if current_tf == "1" or current_tf == "3"
            "5"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "D"

f_rolling_vwap(days) => // Function to calculate rolling VWAP
    time_window = days * 24 * 60 * 60 * 1000
    sum_src_vol = pc.totalForTimeWhen(vwapSource * volume, time_window, true, 10)
    sum_vol = pc.totalForTimeWhen(volume, time_window, true, 10)
    sum_vol == 0 ? na : sum_src_vol / sum_vol

f_rolling_vwap_for_small_tf(days, ref_tf) => // Function to calculate rolling VWAP for small timeframes
    request.security(syminfo.tickerid, ref_tf, f_rolling_vwap(days))

f_is_new_period(anchor) => // Function to check if it's a new period for anchored VWAP
    anchor_tf = switch anchor
        'Day'     => 'D'
        'Week'    => 'W'
        'Month'   => 'M'
        'Quarter' => '3M'
        'Year'    => '12M'
        => '' // Default case
    anchor_tf == '' ? false : timeframe.change(anchor_tf)


calculate_basic_vwap(src, reset_condition) => // Function to calculate basic VWAP and bands
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    [_vwap, _stdev_upper_band, _] = ta.vwap(src, reset_condition, 1)
    if not na(_vwap)
        vwapValue := _vwap
        if not na(_stdev_upper_band)
            stdev_abs = _stdev_upper_band - vwapValue
            upperBand := vwapValue + stdev_abs
            lowerBand := vwapValue - stdev_abs
        else
            upperBand := na
            lowerBand := na
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap_native(src, is_active, is_new_period) =>
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    if is_active and not timeframe.isdwm
        [_vwap, _stdev_upper_band, _] = ta.vwap(src, is_new_period, 1)
        if not na(_vwap)
            vwapValue := _vwap
            if not na(_stdev_upper_band)
                stdev_abs = _stdev_upper_band - vwapValue
                upperBand := vwapValue + stdev_abs
                lowerBand := vwapValue - stdev_abs
            else
                upperBand := na
                lowerBand := na
        else
            vwapValue := na
            upperBand := na
            lowerBand := na
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap_adaptive(src, is_active, anchor_period) =>
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    if is_active
        string vwap_type = 'default'
        if anchor_period == 'Year'
            vwap_type := 'yearly'
        else if anchor_period == 'Quarter'
            vwap_type := 'quarterly'
        else if anchor_period == 'Month'
            vwap_type := 'monthly'
        else if anchor_period == 'Week'
            vwap_type := 'weekly'
        else if anchor_period == 'Day'
            vwap_type := 'daily'
        ref_tf = get_adaptive_anchor_tf(vwap_type)
            
        isWeekStart = dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday)
        isMonthStart = month(time) != month(time[1])
        isQuarterStart = get_quarter(time) != get_quarter(time[1])
        isYearStart = year(time) != year(time[1])
        isDayStart = dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1])
        period_start_condition = anchor_period == 'Week' ? isWeekStart : anchor_period == 'Month' ? isMonthStart : anchor_period == 'Quarter' ? isQuarterStart : anchor_period == 'Year' ? isYearStart : anchor_period == 'Day' ? isDayStart : true
        reset_condition = request.security(syminfo.tickerid, ref_tf, period_start_condition, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
        [vwap_value_sec, upper_band_sec, lower_band_sec] = request.security(syminfo.tickerid, ref_tf, calculate_basic_vwap(src, reset_condition), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
        
        vwapValue := vwap_value_sec
        upperBand := upper_band_sec
        lowerBand := lower_band_sec
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap(src, is_active, is_new_period_val, anchor_type) => // Unified function to calculate current VWAP
    if anchor_type == 'Day' and not use_adaptive_tf
        f_calculate_current_vwap_native(src, is_active, is_new_period_val)
    else
        f_calculate_current_vwap_adaptive(src, is_active, anchor_type)

get_fixed_tf_vwap(src, period_type) => // Function to get VWAP for a fixed timeframe
    string vwap_type = 'default'
    if period_type == 'Y'
        vwap_type := 'pyvwap'
    else if period_type == 'Q'
        vwap_type := 'pqvwap'
    else if period_type == 'M'
        vwap_type := 'pmvwap'
    else if period_type == 'W'
        vwap_type := 'pwvwap'
    else if period_type == 'D'
        vwap_type := 'daily'
    ref_tf = get_adaptive_anchor_tf(vwap_type)
    reset_condition_sec = request.security(syminfo.tickerid, ref_tf, period_type == 'W' ? dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday) : period_type == 'M' ? month(time) != month(time[1]) : period_type == 'Q' ? get_quarter(time) != get_quarter(time[1]) : period_type == 'Y' ? year(time) != year(time[1]) : period_type == 'D' ? dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1]) : false, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    [vwap_value_sec, upper_band_sec, lower_band_sec] = request.security(syminfo.tickerid, ref_tf, calculate_basic_vwap(src, reset_condition_sec), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    [vwap_value_sec, upper_band_sec, lower_band_sec]

calculate_period_vwap(src, tf_string) => // Function to calculate period VWAP
    isNewPeriod = timeframe.change(tf_string)
    [vwapVal, upperVal, lowerVal] = calculate_basic_vwap(src, isNewPeriod)
    [vwapVal, upperVal, lowerVal]

detect_period_change(period) => // Function to detect period change
    switch period
        'W' => dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday)
        'M' => month(time) != month(time[1])
        'Q' => get_quarter(time) != get_quarter(time[1])
        'Y' => year(time) != year(time[1])
        => false

calculate_and_store_previous_vwap(period) => // Function to calculate and store previous period VWAP
    is_tf_change = detect_period_change(period)
    float poc = na
    float upper = na
    float lower = na
    int start_index = na
    [cur_poc, cur_upper, cur_lower] = get_fixed_tf_vwap(vwapSource, period)
    if is_tf_change
        poc := cur_poc[1]
        upper := cur_upper[1]
        lower := cur_lower[1]
        start_index := bar_index
    [poc, upper, lower, start_index]

plot_previous_vwap_levels(anchor_str, p_upper, p_lower, p_poc, p_start_bar, vwap_plot_color) => // Function to plot previous VWAP levels
    if not na(p_poc) and not na(p_start_bar)
        int offset_time = time + (pvwap_offset * timeframe.in_seconds(timeframe.period) * 1000) 
        int line_start_time = offset_time - (KEYLEVEL_LINE_LENGTH * timeframe.in_seconds(timeframe.period) * 1000) 
        color labelTextColor = color.new(vwap_plot_color, 45)
        color shortLineColor = color.new(vwap_plot_color, 30)
        string lower_label_text = ""
        string poc_label_text = ""
        string upper_label_text = ""
        if anchor_str == 'Week'
            lower_label_text := "pWvaL"
            poc_label_text := "pWvwap"
            upper_label_text := "pWvaH"
        else if anchor_str == 'Month'
            lower_label_text := "pMvaL"
            poc_label_text := "pMvwap"
            upper_label_text := "pMvaH"
        else if anchor_str == 'Quarter'
            lower_label_text := "pQvaL"
            poc_label_text := "pQvwap"
            upper_label_text := "pQvaH"
        else if anchor_str == 'Year'
            lower_label_text := "pYvaL"
            poc_label_text := "pYvwap"
            upper_label_text := "pYvaH"
        else
            prefix = switch anchor_str
                'Week'    => 'pw'
                'Month'   => 'pm'
                'Quarter' => 'pq'
                'Year'    => 'py'
                => 'p'
            lower_label_text := prefix + 'VWAP -1'
            poc_label_text := prefix + 'VWAP'
            upper_label_text := prefix + 'VWAP +1'
        if not na(p_lower)
            line_lower = get_line_from_pool()
            line_lower.set_xy1(line_start_time, p_lower)
            line_lower.set_xy2(offset_time, p_lower)
            line_lower.set_color(shortLineColor)
            line_lower.set_width(1)
            line_lower.set_style(PVWAP_LINE_STYLE)
            array.push(pvwap_lines, line_lower)
            lbl_lower = get_label_from_pool()
            lbl_lower.set_xy(offset_time, p_lower)
            lbl_lower.set_text(lower_label_text)
            lbl_lower.set_tooltip(str.tostring(p_lower, pvwap_format_level))
            lbl_lower.set_color(label_color_setting)
            lbl_lower.set_textcolor(labelTextColor)
            lbl_lower.set_style(DEFAULT_LABEL_STYLE)
            lbl_lower.set_text_font_family(FONT_MONO)
            array.push(pvwap_labels, lbl_lower)
        if not na(p_upper)
            line_upper = get_line_from_pool()
            line_upper.set_xy1(line_start_time, p_upper)
            line_upper.set_xy2(offset_time, p_upper)
            line_upper.set_color(shortLineColor)
            line_upper.set_width(1)
            line_upper.set_style(PVWAP_LINE_STYLE)
            array.push(pvwap_lines, line_upper)
            lbl_upper = get_label_from_pool()
            lbl_upper.set_xy(offset_time, p_upper)
            lbl_upper.set_text(upper_label_text)
            lbl_upper.set_tooltip(str.tostring(p_upper, pvwap_format_level))
            lbl_upper.set_color(label_color_setting)
            lbl_upper.set_textcolor(labelTextColor)
            lbl_upper.set_style(DEFAULT_LABEL_STYLE)
            lbl_upper.set_text_font_family(FONT_MONO)
            array.push(pvwap_labels, lbl_upper)
        line_poc = get_line_from_pool()
        line_poc.set_xy1(line_start_time, p_poc)
        line_poc.set_xy2(offset_time, p_poc)
        line_poc.set_color(shortLineColor)
        line_poc.set_width(1)
        line_poc.set_style(PVWAP_LINE_STYLE)
        array.push(pvwap_lines, line_poc)
        lbl_poc = get_label_from_pool()
        lbl_poc.set_xy(offset_time, p_poc)
        lbl_poc.set_text(poc_label_text)
        lbl_poc.set_tooltip(str.tostring(p_poc, pvwap_format_level))
        lbl_poc.set_color(label_color_setting)
        lbl_poc.set_textcolor(labelTextColor)
        lbl_poc.set_style(DEFAULT_LABEL_STYLE)
        lbl_poc.set_text_font_family(FONT_MONO)
        array.push(pvwap_labels, lbl_poc)

plot_key_open_level(levelValue, levelName, levelColor, offset_val, format_str) => // Function to plot key open levels
    if not na(levelValue)
        int offset_time = time + (offset_val * timeframe.in_seconds(timeframe.period) * 1000) 
        int line_start_time = offset_time - (KEYLEVEL_LINE_LENGTH * timeframe.in_seconds(timeframe.period) * 1000) 
        color lineColor = levelColor
        color bgColor = label_color_setting
        color labelTextColor = switch levelName
            "YO" => color.new(#BDBDBD, 45)
            "QO" => color.new(#7E57C2, 45)
            "MO" => color.new(#29B6F6, 45)
            "WO" => color.new(#FFCA28, 45)
            "DO" => color.new(#FFFFFF, 45)
            => color.new(levelColor, 45)
        line_obj = get_line_from_pool()
        line_obj.set_xy1(line_start_time, levelValue)
        line_obj.set_xy2(offset_time, levelValue)
        line_obj.set_color(lineColor)
        line_obj.set_width(1)
        line_obj.set_style(PVWAP_LINE_STYLE)
        array.push(key_open_lines, line_obj)
        label_obj = get_label_from_pool()
        label_obj.set_xy(offset_time, levelValue)
        label_obj.set_text(levelName)
        label_obj.set_tooltip(str.tostring(levelValue, format_str))
        label_obj.set_color(bgColor)
        label_obj.set_textcolor(labelTextColor)
        label_obj.set_style(DEFAULT_LABEL_STYLE)
        label_obj.set_text_font_family(FONT_MONO)
        array.push(key_open_labels, label_obj)

// ç”¨äºç»˜åˆ¶æ»šåŠ¨VWAPæ°´å¹³çš„å‡½æ•°ï¼ŒåŒ…å«æ ‡ç­¾å’ŒæŒ‡ç¤ºçº¿
plot_rvwap_level(levelValue, levelName, levelColor, offset_val, format_str) =>
    if not na(levelValue)
        // è®¡ç®—æŒ‡æ ‡çº¿å’Œæ ‡ç­¾çš„æ—¶é—´åæ ‡
        int offset_time = time + (offset_val * timeframe.in_seconds(timeframe.period) * 1000)
        int line_start_time = offset_time - (KEYLEVEL_LINE_LENGTH * timeframe.in_seconds(timeframe.period) * 1000)

        // --- çº¿æ¡å¯¹è±¡çš„åˆ›å»ºä¸é…ç½® ---
        line line_obj = get_line_from_pool()
        line_obj.set_xy1(line_start_time, levelValue)
        line_obj.set_xy2(offset_time, levelValue)
        line_obj.set_color(levelColor)
        line_obj.set_width(1)
        line_obj.set_style(PVWAP_LINE_STYLE) // å¤ç”¨ç°æœ‰æ ·å¼ä»¥ä¿æŒè§†è§‰ä¸€è‡´æ€§
        array.push(rvwap_lines, line_obj) // å…³é”®æ­¥éª¤ï¼šå°†å¯¹è±¡æ·»åŠ åˆ°è¿½è¸ªæ•°ç»„

        // --- æ ‡ç­¾å¯¹è±¡çš„åˆ›å»ºä¸é…ç½® ---
        label label_obj = get_label_from_pool()
        label_obj.set_xy(offset_time, levelValue)
        label_obj.set_text(levelName)
        label_obj.set_tooltip(str.tostring(levelValue, format_str))
        label_obj.set_color(label_color_setting) // å¤ç”¨ç°æœ‰èƒŒæ™¯è‰²ä»¥ä¿æŒè§†è§‰ä¸€è‡´æ€§
        label_obj.set_textcolor(color.new(levelColor, 45)) // åŸºäºçº¿æ¡é¢œè‰²åŠ¨æ€ç”Ÿæˆæ–‡æœ¬é¢œè‰²
        label_obj.set_style(DEFAULT_LABEL_STYLE)
        label_obj.set_text_font_family(FONT_MONO)
        array.push(rvwap_labels, label_obj) // å…³é”®æ­¥éª¤ï¼šå°†å¯¹è±¡æ·»åŠ åˆ°è¿½è¸ªæ•°ç»„

f_get_yearly_open() => // Function to get yearly open price
    var float yo = na
    if year(time) != year(time[1]) or na(yo)
        yo := open
    yo

f_get_monthly_open() => // Function to get monthly open price
    var float mo = na
    if month(time) != month(time[1]) or na(mo)
        mo := open
    mo

f_get_quarterly_open() => // Function to get quarterly open price
    var float qo = na
    if get_quarter(time) != get_quarter(time[1]) or na(qo)
        qo := open
    qo

f_get_weekly_open() => // Function to get weekly open price
    var float wo = na
    if dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday or na(wo))
        wo := open
    wo

f_get_daily_open() => // Function to get daily open price
    var float d_open = na
    if dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1]) or na(d_open)
        d_open := open
    d_open

// @function ä¸€æ¬¡æ€§è·å–æ‰€æœ‰å‘¨æœŸçš„å¼€ç›˜ä»·
// @returns [å¹´åº¦å¼€ç›˜, æœˆåº¦å¼€ç›˜, å­£åº¦å¼€ç›˜, å‘¨çº¿å¼€ç›˜, æ—¥çº¿å¼€ç›˜]
f_get_all_opens() =>
    var float yo = na
    var float mo = na
    var float qo = na
    var float wo = na
    var float d_open = na
    
    // å¹´åº¦å¼€ç›˜
    if year(time) != year(time[1]) or na(yo)
        yo := open
    
    // æœˆåº¦å¼€ç›˜
    if month(time) != month(time[1]) or na(mo)
        mo := open
    
    // å­£åº¦å¼€ç›˜
    if get_quarter(time) != get_quarter(time[1]) or na(qo)
        qo := open
    
    // å‘¨çº¿å¼€ç›˜ï¼ˆå‘¨ä¸€ï¼‰
    if dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday or na(wo))
        wo := open
    
    // æ—¥çº¿å¼€ç›˜
    if dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1]) or na(d_open)
        d_open := open
        
    [yo, mo, qo, wo, d_open]

// ---- ä¼˜åŒ–ä»£ç ï¼ˆæ›¿æ¢5è¡Œç‹¬ç«‹è°ƒç”¨ï¼‰----
[yearOpen_ref, monthOpen_ref, quarterOpen_ref, weekOpen_ref, dailyOpen_ref] = if use_ref_tf_for_opens
    request.security(syminfo.tickerid, "D", f_get_all_opens(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
else
    [na, na, na, na, na]

// =============================================================================
// ==== CALCULATIONS (Main Script Logic) ====
// =============================================================================

// ==== Market Order Bubble Calculations ====
// ã€ä¿®æ”¹ã€‘ä¸ºæ‰€æœ‰å˜é‡å£°æ˜ä¸€ä¸ªé»˜è®¤å€¼
float netDelta = 0.0
float deltaZscore = 0.0
bool showBubble = false

// ã€ä¿®æ”¹ã€‘åªæœ‰åœ¨å¼€å…³æ‰“å¼€æ—¶ï¼Œæ‰æ‰§è¡Œæ‰€æœ‰æ¶ˆè€—èµ„æºçš„è®¡ç®—
if enable_mob
    string finalLowerTf = i_useCustomTf ? i_lowerTf : f_autoLowerTf()
    [buyVolume, sellVolume] = f_getVolumeDelta(finalLowerTf)
    netDelta := buyVolume - sellVolume
    float avgDelta = ta.sma(netDelta, i_statLookback)
    float stdevDelta = ta.stdev(netDelta, i_statLookback)
    deltaZscore := stdevDelta > 0 ? (netDelta - avgDelta) / stdevDelta : 0

    bool isAllowedTimeframe = not i_filterTimeframe or (timeframe.isintraday and timeframe.multiplier <= 15)
    bool isWithinDateRange = not i_filterDate or (timenow - time < i_daysToShow * 24 * 60 * 60 * 1000)

    showBubble := isAllowedTimeframe and isWithinDateRange and math.abs(deltaZscore) >= i_zscoreThreshold

// ==== Abnormal Volume & Intrabar Profile Calculations ====

// -- 1. æ£€æµ‹å¼‚å¸¸æˆäº¤é‡
float avp_vol_sma = ta.sma(volume, avp_ma_period)
bool avp_is_abnormal_volume = volume > avp_vol_sma * avp_vol_multiplier

// -- 2. å¦‚æœæ˜¯å¼‚å¸¸æˆäº¤é‡Kçº¿ï¼Œåˆ™è¯·æ±‚æ›´å°å‘¨æœŸçš„æ•°æ®
if avp_is_abnormal_volume and barstate.isconfirmed
    [tmp_high, tmp_low, tmp_close, tmp_open, tmp_volume] = request.security_lower_tf(syminfo.tickerid, avp_ltf_timeframe, [high, low, close, open, volume])
    avp_ltf_high := tmp_high
    avp_ltf_low := tmp_low
    avp_ltf_close := tmp_close
    avp_ltf_open := tmp_open
    avp_ltf_volume := tmp_volume
else
    // å¦‚æœä¸æ˜¯å¼‚å¸¸Kçº¿ï¼Œåˆ™æ¸…ç©ºæ•°ç»„ä»¥èŠ‚çº¦å†…å­˜
    array.clear(avp_ltf_high)
    array.clear(avp_ltf_low)
    array.clear(avp_ltf_close)
    array.clear(avp_ltf_open)
    array.clear(avp_ltf_volume)

// -- 3. å¦‚æœå°å‘¨æœŸæ•°æ®å­˜åœ¨ï¼Œåˆ™è¿›è¡Œå‰–æè®¡ç®—
if array.size(avp_ltf_high) > 0
    // -- 3a. åˆå§‹åŒ–è®¡ç®—å˜é‡
    float avp_vpoc_price = na
    float avp_cumulative_delta = na
    float bar_range = high - low
    float bin_height = bar_range > 0 ? bar_range / avp_profile_rows : 0

    // -- 3b. æ„å»ºä»·æ ¼åŒºé—´æ•°ç»„
    array<float> price_bins = array.new_float(avp_profile_rows)
    array<float> total_volume_per_bin = array.new_float(avp_profile_rows, 0)
    array<float> buy_volume_per_bin = array.new_float(avp_profile_rows, 0)
    array<float> sell_volume_per_bin = array.new_float(avp_profile_rows, 0)

    for i = 0 to avp_profile_rows - 1
        array.set(price_bins, i, low + bin_height * (i + 0.5))

    // -- 3c. éå†å°å‘¨æœŸæ•°æ®ï¼Œå¡«å……æˆäº¤é‡åˆ°ä»·æ ¼åŒºé—´
    for i = 0 to array.size(avp_ltf_volume) - 1
        float ltf_c = array.get(avp_ltf_close, i)
        float ltf_o = array.get(avp_ltf_open, i)
        float ltf_vol = array.get(avp_ltf_volume, i)

        if bin_height > 0
            int bin_index = math.max(0, math.min(avp_profile_rows - 1, math.round((ltf_c - low) / bin_height - 0.5)))
            array.set(total_volume_per_bin, bin_index, array.get(total_volume_per_bin, bin_index) + ltf_vol)
            if ltf_c > ltf_o
                array.set(buy_volume_per_bin, bin_index, array.get(buy_volume_per_bin, bin_index) + ltf_vol)
            else if ltf_c < ltf_o
                array.set(sell_volume_per_bin, bin_index, array.get(sell_volume_per_bin, bin_index) + ltf_vol)

    // -- 3d. è®¡ç®— VPOC (æˆäº¤é‡æœ€é«˜ç‚¹) å’Œ Delta
    float max_volume_in_profile = array.max(total_volume_per_bin)
    if max_volume_in_profile > 0
        int max_volume_index = array.indexof(total_volume_per_bin, max_volume_in_profile)
        avp_vpoc_price := array.get(price_bins, max_volume_index)

    avp_cumulative_delta := array.sum(buy_volume_per_bin) - array.sum(sell_volume_per_bin)

    // -- 3e. ç»˜åˆ¶VPOCæ°´å¹³çº¿(ä½¿ç”¨å—æ§çš„FIFOé˜Ÿåˆ—è¿›è¡Œç®¡ç†)
    if not na(avp_vpoc_price)
        // ä¿®å¤: åœ¨åˆ›å»ºæ–°çº¿æ¡å‰ï¼Œæ£€æŸ¥æ˜¯å¦å·²è¾¾åˆ°æ•°é‡ä¸Šé™
        if array.size(avp_lines) >= avp_max_lines
            // å¦‚æœè¾¾åˆ°ä¸Šé™,åˆ™ç§»é™¤å¹¶åˆ é™¤æœ€æ—§çš„çº¿æ¡(é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ª)
            line oldest_line = array.shift(avp_lines)
            line.delete(oldest_line)

        // åˆ›å»ºæ–°çš„AVPçº¿æ¡ï¼Œå¹¶æ•è·å…¶ID
        color line_color = avp_cumulative_delta > 0 ? avp_pos_delta_color : avp_neg_delta_color
        line new_avp_line = line.new(x1=bar_index - 1, y1=avp_vpoc_price, x2=bar_index, y2=avp_vpoc_price, xloc=xloc.bar_index, extend=extend.none, color=line_color, width=avp_vpoc_line_width)

        // ä¿®å¤: å°†æ–°åˆ›å»ºçš„çº¿æ¡IDå­˜å…¥ç®¡ç†æ•°ç»„ä¸­ï¼Œä»¥ä¾¿åç»­è¿½è¸ªå’Œåˆ é™¤
        array.push(avp_lines, new_avp_line)

[isNewDay, isNewWeek, isNewMonth, isNewQuarter, isNewYear, current_day, current_month, current_year, current_quarter, current_dayofweek] = detect_timeframe_changes()

cached_day := current_day
cached_month := current_month
cached_year := current_year
cached_quarter := current_quarter
cached_dayofweek := current_dayofweek

// æ£€æµ‹å„å‘¨æœŸå¼€å§‹
isNewWeekPeriod := dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday)
isNewMonthPeriod := month(time) != month(time[1])
isNewQuarterPeriod := get_quarter(time) != get_quarter(time[1])
isNewYearPeriod := year(time) != year(time[1])
isNewDayPeriod := dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1])

bool is_small_tf = timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds("60") 
rvwap_7d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(7, rvwap_ref_tf) : f_rolling_vwap(7)
rvwap_30d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(30, rvwap_ref_tf) : f_rolling_vwap(30)
rvwap_90d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(90, rvwap_ref_tf) : f_rolling_vwap(90)
rvwap_365d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(365, rvwap_ref_tf) : f_rolling_vwap(365)

rvwap_7d = ta.sma(rvwap_7d_raw, rvwap_smoothing)
rvwap_30d = ta.sma(rvwap_30d_raw, rvwap_smoothing)
rvwap_90d = ta.sma(rvwap_90d_raw, rvwap_smoothing)
rvwap_365d = ta.sma(rvwap_365d_raw, rvwap_smoothing)

string curr_tf_period = timeframe.period
int current_tf_seconds_val = timeframe.in_seconds(timeframe.period) 

int SECONDS_4H_VAL = 4 * 60 * 60
int SECONDS_12H_VAL = 12 * 60 * 60
int SECONDS_1D_VAL = 24 * 60 * 60
int SECONDS_1W_VAL = 7 * 24 * 60 * 60

bool is_4h_or_higher_tf = current_tf_seconds_val >= SECONDS_4H_VAL
bool is_12h_or_higher_tf = current_tf_seconds_val >= SECONDS_12H_VAL
bool is_weekly_or_higher_tf = current_tf_seconds_val >= SECONDS_1W_VAL
bool is_monthly_or_higher_tf = curr_tf_period == "M" or curr_tf_period == "3M" or curr_tf_period == "6M" or curr_tf_period == "12M"

[vwap1, band1_upper, band1_lower] = f_calculate_current_vwap(vwapSource, VWAP1_Ctl, f_is_new_period(Anchor1), Anchor1)
[vwap2, band2_upper, band2_lower] = f_calculate_current_vwap(vwapSource, VWAP2_Ctl, f_is_new_period(Anchor2), Anchor2)
[vwap3, band3_upper, band3_lower] = f_calculate_current_vwap(vwapSource, VWAP3_Ctl, f_is_new_period(Anchor3), Anchor3)
[vwap4, band4_upper, band4_lower] = f_calculate_current_vwap(vwapSource, VWAP4_Ctl, f_is_new_period(Anchor4), Anchor4)
[vwap5, band5_upper, band5_lower] = f_calculate_current_vwap(vwapSource, VWAP5_Ctl, f_is_new_period(Anchor5), Anchor5)

[yearly_period_vwap, yearly_period_upper, yearly_period_lower] = calculate_period_vwap(vwapSource, '12M')
[quarterly_period_vwap, quarterly_period_upper, quarterly_period_lower] = calculate_period_vwap(vwapSource, '3M')
[monthly_period_vwap, monthly_period_upper, monthly_period_lower] = calculate_period_vwap(vwapSource, 'M')
[weekly_period_vwap, weekly_period_upper, weekly_period_lower] = calculate_period_vwap(vwapSource, 'W')

[yearly_poc_val, yearly_upper_val, yearly_lower_val, yearly_start_val] = calculate_and_store_previous_vwap('Y')
[quarterly_poc_val, quarterly_upper_val, quarterly_lower_val, quarterly_start_val] = calculate_and_store_previous_vwap('Q')
[monthly_poc_val, monthly_upper_val, monthly_lower_val, monthly_start_val] = calculate_and_store_previous_vwap('M')
[weekly_poc_val, weekly_upper_val, weekly_lower_val, weekly_start_val] = calculate_and_store_previous_vwap('W')


if not na(weekly_poc_val) and not na(weekly_start_val)
    lastWeeklyPOC := weekly_poc_val
    lastWeeklyUpper := weekly_upper_val
    lastWeeklyLower := weekly_lower_val
    thisWeekStart := int(weekly_start_val)
else if isNewWeek
    lastWeeklyLower := weekly_period_lower[1]
    lastWeeklyUpper := weekly_period_upper[1]
    lastWeeklyPOC := weekly_period_vwap[1]
    thisWeekStart := bar_index

if not na(monthly_poc_val) and not na(monthly_start_val)
    lastMonthlyPOC := monthly_poc_val
    lastMonthlyUpper := monthly_upper_val
    lastMonthlyLower := monthly_lower_val
    thisMonthStart := int(monthly_start_val)
else if isNewMonth
    lastMonthlyLower := monthly_period_lower[1]
    lastMonthlyUpper := monthly_period_upper[1]
    lastMonthlyPOC := monthly_period_vwap[1]
    thisMonthStart := bar_index

if not na(quarterly_poc_val) and not na(quarterly_start_val)
    lastQuarterlyPOC := quarterly_poc_val
    lastQuarterlyUpper := quarterly_upper_val
    lastQuarterlyLower := quarterly_lower_val
    thisQuarterStart := int(quarterly_start_val)
else if isNewQuarter
    lastQuarterlyLower := quarterly_period_lower[1]
    lastQuarterlyUpper := quarterly_period_upper[1]
    lastQuarterlyPOC := quarterly_period_vwap[1]
    thisQuarterStart := bar_index

if not na(yearly_poc_val) and not na(yearly_start_val)
    lastYearlyPOC := yearly_poc_val
    lastYearlyUpper := yearly_upper_val
    lastYearlyLower := yearly_lower_val
    thisYearStart := int(yearly_start_val)
else if isNewYear
    lastYearlyLower := yearly_period_lower[1]
    lastYearlyUpper := yearly_period_upper[1]
    lastYearlyPOC := yearly_period_vwap[1]
    thisYearStart := bar_index

bool valid_yearOpen_val = not na(yearOpen_ref) and yearOpen_ref > 0
bool valid_monthOpen_val = not na(monthOpen_ref) and monthOpen_ref > 0
bool valid_weekOpen_val = not na(weekOpen_ref) and weekOpen_ref > 0
bool valid_quarterOpen_val = not na(quarterOpen_ref) and quarterOpen_ref > 0
bool valid_dailyOpen_val = not na(dailyOpen_ref) and dailyOpen_ref > 0

if isNewMonth or na(monthlyOpen[1])
    monthlyOpen := valid_monthOpen_val and use_ref_tf_for_opens ? monthOpen_ref : open
if isNewYear or na(yearlyOpen[1])
    yearlyOpen := valid_yearOpen_val and use_ref_tf_for_opens ? yearOpen_ref : open
if isNewWeek or na(weeklyOpen[1])
    weeklyOpen := valid_weekOpen_val and use_ref_tf_for_opens ? weekOpen_ref : open
if isNewQuarter or na(quarterlyOpen[1])
    quarterlyOpen := valid_quarterOpen_val and use_ref_tf_for_opens ? quarterOpen_ref : open 
if isNewDay or na(dailyOpen[1])
    dailyOpen := valid_dailyOpen_val and use_ref_tf_for_opens ? dailyOpen_ref : open

bool isMondayNow = dayofweek(time) == dayofweek.monday
if isNewWeek
    prevMondayHigh := mondayHigh
    prevMondayLow := mondayLow
    prevMondayStartBar := mondayStartBar
    prevWeekEndBar := bar_index[1]
    mondayHigh := na
    mondayLow := na
    mondayStartBar := na
    mondayEndBar := na
    if not na(mondayStartBar) and (bar_index - mondayStartBar >=0) 
        prevMondayStartTime := time[bar_index - mondayStartBar] 
    else
        prevMondayStartTime := na 
    prevWeekEndTime := time[1]  
if isMondayNow
    if na(mondayStartBar)
        mondayStartBar := bar_index
        mondayHigh := high
        mondayLow := low
    else
        mondayHigh := math.max(na(mondayHigh) ? high : mondayHigh, high)
        mondayLow := math.min(na(mondayLow) ? low : mondayLow, low)
    mondayEndBar := bar_index

// ---- Volume Profile Calculations ----
if vp_enable
    vp_res_tf_str = timeframe.in_seconds(vp_resolution_tf) <= timeframe.in_seconds() ? vp_resolution_tf : timeframe.period
    [ltf_H_arr, ltf_L_arr, ltf_V_arr] = request.security_lower_tf(syminfo.tickerid, vp_res_tf_str, [high, low, volume])

    // æ›´æ–°æœ€å¤§å†å²é…ç½®æ–‡ä»¶æ•°é‡
    max_historical_profiles := vp_max_history

    if not na(vp_last_bar_idx_profile_start)
        // Determine the lookback period for the current profile
        lookback_bars = bar_index - vp_last_bar_idx_profile_start > 0 ? bar_index - vp_last_bar_idx_profile_start : 1

        // Determine high and low for the current profile period
        profile_high_price = ta.highest(high[1], lookback_bars) // Use high[1] to avoid current bar's forming high
        profile_low_price = ta.lowest(low[1], lookback_bars)   // Use low[1] to avoid current bar's forming low

        // Recalculate profile on new period or on the last bar
        is_new_vp_period = timeframe.change(vp_profile_tf)

        if is_new_vp_period or barstate.islast
            // ã€ä¿®å¤ã€‘é™åˆ¶å®é™…è¡Œæ•°ä¸è¶…è¿‡é¢„åˆ†é…å®¹é‡
            vp_active_rows := math.min(vp_rows, MAX_VP_ROWS)
    
            // ã€ä¿®å¤ã€‘é‡ç”¨é¢„åˆ†é…æ•°ç»„ï¼Œç”¨fillæ¸…é›¶ï¼ˆæ€§èƒ½æå‡å…³é”®ï¼‰
            array.fill(vp_volume_values, 0.0)
            // åªåˆå§‹åŒ–å®é™…éœ€è¦çš„è¡Œæ•°
            if vp_active_rows > 0
                float price_step = (profile_high_price - profile_low_price) / math.max(1, vp_active_rows - 1)
                for i = 0 to vp_active_rows - 1
                    // ã€ä¿®å¤ã€‘ä½¿ç”¨array.setå¹¶ç¡®ä¿ç´¢å¼•å®‰å…¨
                    safe_set_y_coord(i, profile_low_price + i * price_step)
                if vp_active_rows > 1
                    array.set(vp_y_coords, vp_active_rows - 1, profile_high_price)
        
                // æ‰¹é‡è®¾ç½®æ—¶é—´åæ ‡
                for i = 0 to vp_active_rows - 1
                    array.set(vp_x_coords, i, vp_last_time_profile_start)

            // Aggregate volume from lower timeframe data
            float _price_step = (vp_active_rows > 1 and profile_high_price > profile_low_price) ? (profile_high_price - profile_low_price) / (vp_active_rows - 1) : 0.0
            float inv_price_step = _price_step != 0 ? 1 / _price_step : 0

            int end_bar_offset = barstate.islast ? 0 : 1
            // ä¼˜åŒ–æˆäº¤é‡åˆ†é…å¾ªç¯
            for i = lookback_bars - end_bar_offset to 0
                vol_at_bar_arr = ltf_V_arr[i] 
                high_at_bar_arr = ltf_H_arr[i]
                low_at_bar_arr = ltf_L_arr[i]

                if array.size(vol_at_bar_arr) > 0
                    int size_vol = array.size(vol_at_bar_arr)
                    for k = 0 to size_vol - 1
                        float ltf_bar_vol = array.get(vol_at_bar_arr, k)
                        if ltf_bar_vol <= 0
                            continue
                            
                        // å…ˆè·å–å½“å‰å°å‘¨æœŸçš„é«˜ä½
                        float ltf_bar_high = array.get(high_at_bar_arr, k)
                        float ltf_bar_low = array.get(low_at_bar_arr, k)
                        
                        // å¤„ç†å•è¡Œæƒ…å†µï¼ˆprofileé«˜åº¦ä¸º0ï¼‰
                        if profile_high_price == profile_low_price
                            if ltf_bar_low <= profile_low_price and ltf_bar_high >= profile_low_price
                                array.set(vp_volume_values, 0, array.get(vp_volume_values, 0) + ltf_bar_vol)
                            continue
                            
                        // ä½¿ç”¨æ•´æ•°è¿ç®—è®¡ç®—è¡Œç´¢å¼•ï¼ˆä¼˜åŒ–æµ®ç‚¹è¿ç®—ï¼‰
                        float low_offset = (ltf_bar_low - profile_low_price) * inv_price_step
                        float high_offset = (ltf_bar_high - profile_low_price) * inv_price_step
                        int start_row_idx = int(math.max(0, low_offset))
                        int end_row_idx = int(math.min(vp_active_rows - 1, high_offset))
                        
                        // å¿«é€Ÿæ£€æŸ¥æ˜¯å¦éœ€è¦å¤„ç†
                        if start_row_idx > vp_active_rows - 1 or end_row_idx < 0
                            continue
                            
                        // ç¡®ä¿æœ‰æ•ˆèŒƒå›´
                        start_row_idx := math.max(0, start_row_idx)
                        end_row_idx := math.min(vp_active_rows - 1, end_row_idx)
                        
                        if start_row_idx <= end_row_idx
                            int num_rows_spanned = end_row_idx - start_row_idx + 1
                            float vol_per_spanned_row = ltf_bar_vol / num_rows_spanned
                            
                            // ç›´æ¥ç´¯åŠ æˆäº¤é‡
                            for j = start_row_idx to end_row_idx
                                if j >= 0 and j < vp_active_rows  // åŒé‡ä¿é™©ï¼Œç¡®ä¿å®‰å…¨
                                    current_vol = safe_get_volume(j)
                                    safe_set_volume(j, current_vol + vol_per_spanned_row)

            // Find VPOC (price level with max volume)
            // ã€ä¿®å¤ã€‘æ‰‹åŠ¨éå†å‰ vp_active_rows ä¸ªå…ƒç´ æ‰¾æœ€å¤§å€¼
            max_volume_for_poc = 0.0
            int poc_index = na
            if vp_active_rows > 0
                // åˆå§‹åŒ–ç¬¬ä¸€ä¸ªå…ƒç´ 
                max_volume_for_poc := array.get(vp_volume_values, 0)
                poc_index := 0

                // åªéå†å®é™…ä½¿ç”¨çš„è¡Œæ•°
                for i = 1 to vp_active_rows - 1
                    float current_vol = array.get(vp_volume_values, i)
                    if current_vol > max_volume_for_poc
                        max_volume_for_poc := current_vol
                        poc_index := i

            poc_price = poc_index >= 0 ? array.get(vp_y_coords, poc_index) : na


            // ä¼˜åŒ–åçš„Value Areaè®¡ç®—ç®—æ³•
            vp_value_area_low_idx := na
            vp_value_area_high_idx := na

            // åªç´¯åŠ å®é™…ä½¿ç”¨çš„è¡Œæ•°
            float total_volume = 0.0
            for i = 0 to vp_active_rows - 1
                total_volume += array.get(vp_volume_values, i)

            // ä¼˜åŒ–æ‰©å±•ç®—æ³•
            if total_volume > 0
                poc_index := array.indexof(vp_volume_values, max_volume_for_poc) 
                float target_volume = total_volume * 0.68
                float current_volume = array.get(vp_volume_values, poc_index)
                
                vp_value_area_low_idx := poc_index
                vp_value_area_high_idx := poc_index
                
                int l_ptr = poc_index - 1
                int r_ptr = poc_index + 1
                int loop_count = 0
                int max_loops = vp_active_rows * 2  // é˜²æ­¢æ— é™å¾ªç¯
                
                while current_volume < target_volume and loop_count < max_loops
                    loop_count += 1
                    float vol_left = l_ptr >= 0 ? array.get(vp_volume_values, l_ptr) : -1
                    float vol_right = r_ptr < vp_active_rows ? array.get(vp_volume_values, r_ptr) : -1
                    
                    if vol_left > vol_right
                        current_volume += vol_left
                        vp_value_area_low_idx := l_ptr
                        l_ptr -= 1
                    else
                        current_volume += vol_right
                        vp_value_area_high_idx := r_ptr
                        r_ptr += 1
            
            // Prepare polyline points
            // ã€ä¿®å¤ã€‘æ‰‹åŠ¨éå†å‰ vp_active_rows ä¸ªå…ƒç´ æ‰¾æœ€å¤§å€¼
            float max_vol_in_active_range = 0.0
            if vp_active_rows > 0
                max_vol_in_active_range := array.get(vp_volume_values, 0)
                for i = 1 to vp_active_rows - 1
                    float current_vol = array.get(vp_volume_values, i)
                    if current_vol > max_vol_in_active_range
                        max_vol_in_active_range := current_vol

            max_aggregated_volume = max_vol_in_active_range > 0 ? max_vol_in_active_range : 1
            
            base_time_width = float(time[0] - vp_last_time_profile_start) // Ensure float for calculation

            var float time_width_for_profile = 0.0  // ä½¿ç”¨ var ä½¿å…¶è·¨Kçº¿ä¿æŒå€¼

            if vp_extend_profile_percent == 0
                // If extend percent is 0, use the base time width, ensuring it's at least 1
                time_width_for_profile := base_time_width > 0 ? base_time_width : 1.0
            else
                // Calculate width based on extend percentage
                calculated_width = base_time_width * (vp_extend_profile_percent / 100.0)
                // Ensure the calculated width is at least 1
                time_width_for_profile := calculated_width > 0 ? calculated_width : 1.0
            
            // Final defensive check to ensure time_width_for_profile is positive, at least 1.0
            time_width_for_profile := time_width_for_profile > 0 ? time_width_for_profile : 1.0

            scaling_factor = max_aggregated_volume / time_width_for_profile
            scaling_factor := scaling_factor > 0 ? scaling_factor : 1 // Avoid division by zero or negative scaling

            for j = 0 to vp_active_rows - 1
                scaled_volume_as_time_offset = math.floor(array.get(vp_volume_values, j) / scaling_factor)
                safe_set_x_coord(j, vp_last_time_profile_start + scaled_volume_as_time_offset)

            // Build points for polyline
            array.clear(vp_profile_points_array)
            array.push(vp_profile_points_array, chart.point.from_time(vp_last_time_profile_start, profile_low_price))
            for i = 0 to vp_active_rows - 1
                array.push(vp_profile_points_array, chart.point.from_time(array.get(vp_x_coords, i), array.get(vp_y_coords, i)))
            array.push(vp_profile_points_array, chart.point.from_time(vp_last_time_profile_start, profile_high_price))
            
            // æ„å»ºValue Areaçš„ç‚¹é˜µåˆ—
            array.clear(vp_value_area_points_array)
            if not na(vp_value_area_low_idx) and not na(vp_value_area_high_idx) and vp_value_area_low_idx >= 0 and vp_value_area_high_idx >= 0 and vp_value_area_low_idx < array.size(vp_y_coords) and vp_value_area_high_idx < array.size(vp_y_coords)
                // æ·»åŠ Value Areaä¸‹è¾¹ç•Œç‚¹
                value_area_low_price = array.get(vp_y_coords, vp_value_area_low_idx)
                value_area_high_price = array.get(vp_y_coords, vp_value_area_high_idx)
                
                array.push(vp_value_area_points_array, chart.point.from_time(vp_last_time_profile_start, value_area_low_price))
                
                // æ·»åŠ Value Areaå³ä¾§è¾¹ç•Œç‚¹
                for i = vp_value_area_low_idx to vp_value_area_high_idx
                    if i >= 0 and i < array.size(vp_x_coords) and i < array.size(vp_y_coords)
                        array.push(vp_value_area_points_array, chart.point.from_time(array.get(vp_x_coords, i), array.get(vp_y_coords, i)))
                
                // æ·»åŠ Value Areaä¸Šè¾¹ç•Œç‚¹
                array.push(vp_value_area_points_array, chart.point.from_time(vp_last_time_profile_start, value_area_high_price))

            // Delete old polyline and draw new one
            if not na(vp_current_profile_polyline)
                vp_current_profile_polyline.delete()
                vp_current_profile_polyline := na
                
            if not na(vp_current_value_area_polyline)
                vp_current_value_area_polyline.delete()
                vp_current_value_area_polyline := na

            if vp_show_profile
                vp_current_profile_polyline := polyline.new(vp_profile_points_array, curved = false, closed = true, 
                                   line_color = vp_profile_color, fill_color = vp_profile_color, 
                                   xloc = xloc.bar_time)
                                   
                // å¦‚æœæ˜¾ç¤ºVPï¼ŒåŒæ—¶æ˜¾ç¤ºValue Area
                if array.size(vp_value_area_points_array) > 2
                    vp_current_value_area_polyline := polyline.new(vp_value_area_points_array, curved = false, closed = true, 
                                       line_color = vp_value_area_color, fill_color = vp_value_area_color, 
                                       xloc = xloc.bar_time)

            // Handle VPOC lines and labels
            if is_new_vp_period
                // æ·»åŠ å½“å‰çš„VPå›¾å½¢åˆ°å†å²æ•°ç»„ä¸­
                if vp_show_historical and not na(vp_current_profile_polyline) // profile_low_price and profile_high_price would have been calculated for the period
                    // åˆ›å»ºä¸€ä¸ªæ–°çš„ç‚¹æ•°ç»„ç”¨äºå†å²VP
                    var array<chart.point> historical_points = array.new<chart.point>()
                    array.clear(historical_points)
                    
                    // æ·»åŠ åº•éƒ¨ç‚¹
                    array.push(historical_points, chart.point.from_time(vp_last_time_profile_start, profile_low_price))
                    
                    // æ·»åŠ å³ä¾§ç‚¹
                    for i = 0 to array.size(vp_x_coords) - 1
                        if not na(array.get(vp_x_coords, i)) and not na(array.get(vp_y_coords, i))
                            array.push(historical_points, chart.point.from_time(array.get(vp_x_coords, i), array.get(vp_y_coords, i)))
                    
                    // æ·»åŠ é¡¶éƒ¨ç‚¹
                    array.push(historical_points, chart.point.from_time(vp_last_time_profile_start, profile_high_price))
                    
                    // åˆ›å»ºå†å²VPå›¾å½¢
                    if array.size(historical_points) > 2
                        historical_profile = polyline.new(historical_points, curved = false, closed = true, 
                                               line_color = vp_historical_color, fill_color = vp_historical_color, 
                                               xloc = xloc.bar_time)
                        array.unshift(vp_historical_profiles, historical_profile)
                        
                        // é™åˆ¶å†å²VPæ•°é‡
                        if array.size(vp_historical_profiles) > max_historical_profiles
                            old_profile = array.pop(vp_historical_profiles)
                            polyline.delete(old_profile)
                            
                    // å¦‚æœæœ‰Value Areaæ•°æ®ï¼Œä¹Ÿä¿å­˜ä¸ºå†å²Value Area
                    if not na(vp_value_area_low_idx) and not na(vp_value_area_high_idx) and array.size(vp_value_area_points_array) > 2
                        var array<chart.point> historical_va_points = array.new<chart.point>()
                        array.clear(historical_va_points)
                        
                        // å¤åˆ¶å½“å‰çš„Value Areaç‚¹åˆ°å†å²Value Area
                        for i = 0 to array.size(vp_value_area_points_array) - 1
                            array.push(historical_va_points, array.get(vp_value_area_points_array, i))
                        
                        if array.size(historical_va_points) > 2
                            historical_va = polyline.new(historical_va_points, curved = false, closed = true, 
                                              line_color = vp_value_area_color, fill_color = vp_value_area_color, 
                                              xloc = xloc.bar_time)
                            array.unshift(vp_historical_value_areas, historical_va)
                            
                            // é™åˆ¶å†å²Value Areaæ•°é‡
                            if array.size(vp_historical_value_areas) > max_historical_profiles
                                old_va = array.pop(vp_historical_value_areas)
                                polyline.delete(old_va)

                // ä¿å­˜å½“å‰å‘¨æœŸçš„é«˜ä½ä»·æ ¼ï¼Œç”¨äºä¸‹ä¸€å‘¨æœŸåˆ›å»ºå†å²VP
                vp_last_profile_low := profile_low_price
                vp_last_profile_high := profile_high_price

                // å­˜å‚¨å†å²VPOC
                if vp_show_poc and not na(poc_price)
                    array.unshift(vp_historical_pocs, line.new(vp_last_time_profile_start, poc_price, time, poc_price, 
                                      xloc = xloc.bar_time, color = vp_poc_color, width = 1, style=DEFAULT_LINE_STYLE))
                    // é™åˆ¶å†å²VPOCæ•°é‡
                    if array.size(vp_historical_pocs) > max_historical_profiles * 3
                        line.delete(array.pop(vp_historical_pocs))

                // Clean up current VPOC drawings from previous period (if any) using pool
                if not na(vp_current_poc_main_line)
                    return_line_to_pool(vp_current_poc_main_line)
                    vp_current_poc_main_line := na
                if not na(vp_current_poc_label_line)
                    return_line_to_pool(vp_current_poc_label_line)
                    vp_current_poc_label_line := na
                if not na(vp_current_poc_label)
                    return_label_to_pool(vp_current_poc_label)
                    vp_current_poc_label := na
            
            else if barstate.islast and vp_show_poc // Update current VPOC line and label on last bar
                if na(vp_current_poc_main_line) // First time drawing on last bar or after reset
                    vp_current_poc_main_line := get_line_from_pool()
                    vp_current_poc_label_line := get_line_from_pool()
                    vp_current_poc_label := get_label_from_pool()

                // Update main POC line (from profile start to current bar)
                vp_current_poc_main_line.set_xy1(vp_last_time_profile_start, poc_price)
                vp_current_poc_main_line.set_xy2(time, poc_price)
                vp_current_poc_main_line.set_color(vp_poc_color)
                vp_current_poc_main_line.set_width(1)
                vp_current_poc_main_line.set_style(DEFAULT_LINE_STYLE)
                
                // Update POC label line (short segment at current bar)
                vp_current_poc_label_line.set_xy1(bar_index, poc_price)
                vp_current_poc_label_line.set_xy2(bar_index + vp_label_offset_bars, poc_price)
                vp_current_poc_label_line.set_color(vp_poc_color)
                vp_current_poc_label_line.set_width(1)
                vp_current_poc_label_line.set_style(DEFAULT_LINE_STYLE)
                //vp_current_poc_label_line.set_xloc(xloc.bar_index)

                // Update POC label
                vp_current_poc_label.set_xy(bar_index + vp_label_offset_bars, poc_price)
                vp_current_poc_label.set_text("POC")
                vp_current_poc_label.set_tooltip(str.tostring(poc_price, vp_price_format))
                vp_current_poc_label.set_color(color.new(vp_poc_color, 80)) // Semi-transparent background
                vp_current_poc_label.set_textcolor(color.white) // Contrasting text
                vp_current_poc_label.set_style(label.style_label_left)
                //vp_current_poc_label.set_xloc(xloc.bar_index)

// Update Volume Profile anchor points
if vp_enable
    if timeframe.change(vp_profile_tf) or na(vp_last_bar_idx_profile_start) // Also initialize on first run
        vp_last_bar_idx_profile_start := bar_index
        vp_last_time_profile_start := time

        // When profile TF changes, clear the current POC line/label from the previous profile period
        if not na(vp_current_poc_main_line)
            return_line_to_pool(vp_current_poc_main_line)
            vp_current_poc_main_line := na
        if not na(vp_current_poc_label_line)
            return_line_to_pool(vp_current_poc_label_line)
            vp_current_poc_label_line := na
        if not na(vp_current_poc_label)
            return_label_to_pool(vp_current_poc_label)
            vp_current_poc_label := na
            
        // åŒæ—¶æ¸…ç†Value Areaå¯¹è±¡
        if not na(vp_current_value_area_polyline)
            vp_current_value_area_polyline.delete()
            vp_current_value_area_polyline := na
            
        // é‡ç½®Value Areaç´¢å¼•
        vp_value_area_low_idx := na
        vp_value_area_high_idx := na
        
        // æ¸…ç©ºValue Areaç‚¹é˜µåˆ—
        array.clear(vp_value_area_points_array)


// =============================================================================
// ==== PLOTTING ====
// =============================================================================

// ==== Abnormal Volume Bar Coloring ====
color avp_abnormal_color = na
if avp_is_abnormal_volume
    if close > open
        avp_abnormal_color := avp_abnormal_bull_color // çœ‹æ¶¨åˆ™ä¸ºè“è‰²
    else if close < open
        avp_abnormal_color := avp_abnormal_bear_color // çœ‹è·Œåˆ™ä¸ºçº¢è‰²

barcolor(avp_abnormal_color)

plot(show_7d ? rvwap_7d : na, title='7D RVWAP', color=color_7d, linewidth=1)
plot(show_30d ? rvwap_30d : na, title='30D RVWAP', color=color_30d, linewidth=1)
plot(show_90d ? rvwap_90d : na, title='90D RVWAP', color=color_90d, linewidth=1)
plot(show_365d ? rvwap_365d : na, title='365D RVWAP', color=color_365d, linewidth=1)

// åœ¨ç»˜å›¾éƒ¨åˆ†å¼€å¤´æ·»åŠ è¿™äº›å˜é‡
var bool isNewPeriod1 = f_is_new_period(Anchor1)
var bool isNewPeriod2 = f_is_new_period(Anchor2)
var bool isNewPeriod3 = f_is_new_period(Anchor3)
var bool isNewPeriod4 = f_is_new_period(Anchor4)
var bool isNewPeriod5 = f_is_new_period(Anchor5)

// VWAP 1 (Quarterly) - ä¿®æ­£ç‰ˆ
vwap1_plot_value = master_AVWAP and VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? vwap1 : na
lowerBand1_plot_value = master_AVWAP and VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? band1_lower : na
upperBand1_plot_value = master_AVWAP and VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? band1_upper : na

isNewPeriod1 := f_is_new_period(Anchor1) // æ›´æ–°çŠ¶æ€

vwap_plot1 = plot(vwap1_plot_value, title='VWAP 1', color=isNewPeriod1 ? na : VWAP1_Col, linewidth=1)
lowerBand_1 = plot(lowerBand1_plot_value, title='L Band 1', color=isNewPeriod1 ? na : Bands1_Col, linewidth=1)
upperBand_1 = plot(upperBand1_plot_value, title='U Band 1', color=isNewPeriod1 ? na : Bands1_Col, linewidth=1)

fill(upperBand_1, lowerBand_1, color=isNewPeriod1 ? na : VWAP1_Bgc, title='Fill 1')

// VWAP 2 (Monthly) - ä¿®æ­£ç‰ˆ
vwap2_plot_value = master_AVWAP and VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? vwap2 : na
lowerBand2_plot_value = master_AVWAP and VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? band2_lower : na
upperBand2_plot_value = master_AVWAP and VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? band2_upper : na

isNewPeriod2 := f_is_new_period(Anchor2) // æ›´æ–°çŠ¶æ€

vwap_plot2 = plot(vwap2_plot_value, title='VWAP 2', color=isNewPeriod2 ? na : VWAP2_Col, linewidth=1)
lowerBand_2 = plot(lowerBand2_plot_value, title='L Band 2', color=isNewPeriod2 ? na : Bands2_Col, linewidth=1)
upperBand_2 = plot(upperBand2_plot_value, title='U Band 2', color=isNewPeriod2 ? na : Bands2_Col, linewidth=1)

fill(upperBand_2, lowerBand_2, color=isNewPeriod2 ? na : VWAP2_Bgc, title='Fill 2')

// VWAP 3 (Weekly) - ä¿®æ­£ç‰ˆ
vwap3_plot_value = master_AVWAP and VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? vwap3 : na
lowerBand3_plot_value = master_AVWAP and VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? band3_lower : na
upperBand3_plot_value = master_AVWAP and VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? band3_upper : na

isNewPeriod3 := f_is_new_period(Anchor3) // æ›´æ–°çŠ¶æ€

vwap_plot3 = plot(vwap3_plot_value, title='VWAP 3', color=isNewPeriod3 ? na : VWAP3_Col, linewidth=1)
lowerBand_3 = plot(lowerBand3_plot_value, title='L Band 3', color=isNewPeriod3 ? na : Bands3_Col, linewidth=1)
upperBand_3 = plot(upperBand3_plot_value, title='U Band 3', color=isNewPeriod3 ? na : Bands3_Col, linewidth=1)

fill(upperBand_3, lowerBand_3, color=isNewPeriod3 ? na : VWAP3_Bgc, title='Fill 3')

// VWAP 4 (Daily) - ä¿®æ­£ç‰ˆ
vwap4_plot_value = master_AVWAP and VWAP4_Ctl and not is_4h_or_higher_tf ? vwap4 : na
lowerBand4_plot_value = master_AVWAP and VWAP4_Ctl and not is_4h_or_higher_tf ? band4_lower : na
upperBand4_plot_value = master_AVWAP and VWAP4_Ctl and not is_4h_or_higher_tf ? band4_upper : na

isNewPeriod4 := f_is_new_period(Anchor4) // æ›´æ–°çŠ¶æ€

vwap_plot4 = plot(vwap4_plot_value, title='VWAP 4', color=isNewPeriod4 ? na : VWAP4_Col, linewidth=1)
lowerBand_4 = plot(lowerBand4_plot_value, title='L Band 4', color=isNewPeriod4 ? na : Bands4_Col, linewidth=1)
upperBand_4 = plot(upperBand4_plot_value, title='U Band 4', color=isNewPeriod4 ? na : Bands4_Col, linewidth=1)

fill(upperBand_4, lowerBand_4, color=isNewPeriod4 ? na : VWAP4_Bgc, title='Fill 4')

// VWAP 5 (Yearly) - ä¿®æ­£ç‰ˆ
vwap5_plot_value = master_AVWAP and VWAP5_Ctl ? vwap5 : na
lowerBand5_plot_value = master_AVWAP and VWAP5_Ctl ? band5_lower : na
upperBand5_plot_value = master_AVWAP and VWAP5_Ctl ? band5_upper : na

isNewPeriod5 := f_is_new_period(Anchor5) // æ›´æ–°çŠ¶æ€

vwap_plot5 = plot(vwap5_plot_value, title='VWAP 5', color=isNewPeriod5 ? na : VWAP5_Col, linewidth=1)
lowerBand_5 = plot(lowerBand5_plot_value, title='L Band 5', color=isNewPeriod5 ? na : Bands5_Col, linewidth=1)
upperBand_5 = plot(upperBand5_plot_value, title='U Band 5', color=isNewPeriod5 ? na : Bands5_Col, linewidth=1)

fill(upperBand_5, lowerBand_5, color=isNewPeriod5 ? na : VWAP5_Bgc, title='Fill 5')

if barstate.islast
    // ã€æ ¸å¿ƒä¼˜åŒ–ã€‘æŒ‰å¯¹è±¡ç±»å‹åˆ†ç»„å¢é‡æ›´æ–°ï¼Œé¿å…å…¨é‡é‡å»º
    
    // åˆå§‹åŒ–å„ç»„æ¸…ç†æ ‡å¿—
    bool cleanup_pvwap_needed = false
    bool cleanup_keyopen_needed = false
    bool cleanup_rvwap_needed = false
    
    // ==== 1. æ£€æµ‹ pVWAP ç»„æ˜¯å¦éœ€è¦æ›´æ–° ====
    if na(cache_lastYearlyPOC) or lastYearlyPOC != cache_lastYearlyPOC or
       na(cache_lastQuarterlyPOC) or lastQuarterlyPOC != cache_lastQuarterlyPOC or
       na(cache_lastMonthlyPOC) or lastMonthlyPOC != cache_lastMonthlyPOC or
       na(cache_lastWeeklyPOC) or lastWeeklyPOC != cache_lastWeeklyPOC
        cleanup_pvwap_needed := true
    
    // ==== 2. æ£€æµ‹ Key Open ç»„æ˜¯å¦éœ€è¦æ›´æ–° ====
    if na(cache_yearlyOpen) or yearlyOpen != cache_yearlyOpen or
       na(cache_quarterlyOpen) or quarterlyOpen != cache_quarterlyOpen or
       na(cache_monthlyOpen) or monthlyOpen != cache_monthlyOpen or
       na(cache_weeklyOpen) or weeklyOpen != cache_weeklyOpen or
       na(cache_dailyOpen) or dailyOpen != cache_dailyOpen
        cleanup_keyopen_needed := true
    
    // ==== 3. æ£€æµ‹ RVWAP ç»„æ˜¯å¦éœ€è¦æ›´æ–° ====
    if (show_rvwap_label_7d and (na(cache_rvwap_7d) or rvwap_7d != cache_rvwap_7d)) or
       (show_rvwap_label_30d and (na(cache_rvwap_30d) or rvwap_30d != cache_rvwap_30d)) or
       (show_rvwap_label_90d and (na(cache_rvwap_90d) or rvwap_90d != cache_rvwap_90d)) or
       (show_rvwap_label_365d and (na(cache_rvwap_365d) or rvwap_365d != cache_rvwap_365d))
        cleanup_rvwap_needed := true
    
    // ==== 4. æŒ‰éœ€æ¸…ç†å’Œé‡å»º pVWAP å¯¹è±¡ ====
    if cleanup_pvwap_needed
        // æ¸…ç†pVWAPå¯¹è±¡ï¼ˆæ ‡ç­¾+çº¿æ¡ï¼‰
        if array.size(pvwap_labels) > 0
            for i = 0 to array.size(pvwap_labels) - 1
                return_label_to_pool(array.get(pvwap_labels, i))
            array.clear(pvwap_labels)
        if array.size(pvwap_lines) > 0
            for i = 0 to array.size(pvwap_lines) - 1
                return_line_to_pool(array.get(pvwap_lines, i))
            array.clear(pvwap_lines)
        
        // é‡å»ºpVWAPå¯¹è±¡ï¼ˆä»…å½“æœ‰æ•ˆæ—¶ï¼‰
        if show_pvwap_yearly and not na(lastYearlyPOC) and not na(thisYearStart)
            plot_previous_vwap_levels('Year', lastYearlyUpper, lastYearlyLower, lastYearlyPOC, thisYearStart, color_pvwap_yearly)
        if show_pvwap_quarterly and not na(lastQuarterlyPOC) and not na(thisQuarterStart) and not is_monthly_or_higher_tf
            plot_previous_vwap_levels('Quarter', lastQuarterlyUpper, lastQuarterlyLower, lastQuarterlyPOC, thisQuarterStart, color_pvwap_quarterly)
        if show_pvwap_monthly and not na(lastMonthlyPOC) and not na(thisMonthStart) and not is_weekly_or_higher_tf
            plot_previous_vwap_levels('Month', lastMonthlyUpper, lastMonthlyLower, lastMonthlyPOC, thisMonthStart, color_pvwap_monthly)
        if show_pvwap_weekly and not na(lastWeeklyPOC) and not na(thisWeekStart) and not is_12h_or_higher_tf
            plot_previous_vwap_levels('Week', lastWeeklyUpper, lastWeeklyLower, lastWeeklyPOC, thisWeekStart, color_pvwap_weekly)
        
        // æ›´æ–°pVWAPç›¸å…³ç¼“å­˜
        cache_lastYearlyPOC := lastYearlyPOC
        cache_lastQuarterlyPOC := lastQuarterlyPOC
        cache_lastMonthlyPOC := lastMonthlyPOC
        cache_lastWeeklyPOC := lastWeeklyPOC
    
    // ==== 5. æŒ‰éœ€æ¸…ç†å’Œé‡å»º Key Open å¯¹è±¡ ====
    if cleanup_keyopen_needed
        // æ¸…ç†Key Openå¯¹è±¡ï¼ˆæ ‡ç­¾+çº¿æ¡ï¼‰
        if array.size(key_open_labels) > 0
            for i = 0 to array.size(key_open_labels) - 1
                return_label_to_pool(array.get(key_open_labels, i))
            array.clear(key_open_labels)
        if array.size(key_open_lines) > 0
            for i = 0 to array.size(key_open_lines) - 1
                return_line_to_pool(array.get(key_open_lines, i))
            array.clear(key_open_lines)
        
        // é‡å»ºKey Openå¯¹è±¡ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
        if show_MonthlyOpen and not na(monthlyOpen)
            plot_key_open_level(monthlyOpen, "MO", color_MonthlyOpen, keylevel_offset, keylevel_format)
        if show_YearlyOpen and not na(yearlyOpen)
            plot_key_open_level(yearlyOpen, "YO", color_YearlyOpen, keylevel_offset, keylevel_format)
        if show_WeeklyOpen and not na(weeklyOpen)
            plot_key_open_level(weeklyOpen, "WO", color_WeeklyOpen, keylevel_offset, keylevel_format)
        if show_QuarterlyOpen and not na(quarterlyOpen)
            plot_key_open_level(quarterlyOpen, "QO", color_QuarterlyOpen, keylevel_offset, keylevel_format)
        if show_DailyOpen and not na(dailyOpen)
            plot_key_open_level(dailyOpen, "DO", color_DailyOpen, keylevel_offset, keylevel_format)
        
        // æ›´æ–°Key Openç›¸å…³ç¼“å­˜
        cache_yearlyOpen := yearlyOpen
        cache_quarterlyOpen := quarterlyOpen
        cache_monthlyOpen := monthlyOpen
        cache_weeklyOpen := weeklyOpen
        cache_dailyOpen := dailyOpen
    
    // ==== 6. æŒ‰éœ€æ¸…ç†å’Œé‡å»º RVWAP å¯¹è±¡ ====
    if cleanup_rvwap_needed
        // æ¸…ç†RVWAPå¯¹è±¡ï¼ˆæ ‡ç­¾+çº¿æ¡ï¼‰
        if array.size(rvwap_labels) > 0
            for i = 0 to array.size(rvwap_labels) - 1
                return_label_to_pool(array.get(rvwap_labels, i))
            array.clear(rvwap_labels)
        if array.size(rvwap_lines) > 0
            for i = 0 to array.size(rvwap_lines) - 1
                return_line_to_pool(array.get(rvwap_lines, i))
            array.clear(rvwap_lines)
        
        // é‡å»ºRVWAPå¯¹è±¡ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
        if show_rvwap_label_7d and not na(rvwap_7d)
            plot_rvwap_level(rvwap_7d, "7D", color_7d, rvwap_label_offset, rvwap_label_format)
        if show_rvwap_label_30d and not na(rvwap_30d)
            plot_rvwap_level(rvwap_30d, "30D", color_30d, rvwap_label_offset, rvwap_label_format)
        if show_rvwap_label_90d and not na(rvwap_90d)
            plot_rvwap_level(rvwap_90d, "90D", color_90d, rvwap_label_offset, rvwap_label_format)
        if show_rvwap_label_365d and not na(rvwap_365d)
            plot_rvwap_level(rvwap_365d, "365D", color_365d, rvwap_label_offset, rvwap_label_format)
        
        // æ›´æ–°RVWAPç›¸å…³ç¼“å­˜
        cache_rvwap_7d := rvwap_7d
        cache_rvwap_30d := rvwap_30d
        cache_rvwap_90d := rvwap_90d
        cache_rvwap_365d := rvwap_365d

// ---- Plot Monday Range Lines ----
var line prevMonHighLine = na
var line prevMonLowLine = na
var bool prevMondayLinesDrawn = false // State for previous Monday lines

var line currMonHighLine = na
var line currMonLowLine = na
var float lastPlottedMondayHigh = na // Store last plotted value
var float lastPlottedMondayLow = na  // Store last plotted value
var int lastPlottedMondayStartTime = na // Store last plotted start time
var bool currentMondayLinesActive = false // State for current Monday lines

// Manage Previous Monday lines
if isNewWeek or (prevMondayLinesDrawn and not show_MondayRange)
    if not na(prevMonHighLine)
        return_line_to_pool(prevMonHighLine)
        prevMonHighLine := na
    if not na(prevMonLowLine)
        return_line_to_pool(prevMonLowLine)
        prevMonLowLine := na
    prevMondayLinesDrawn := false

if show_MondayRange and isNewWeek and not na(prevMondayHigh) and not na(prevMondayStartBar) and not na(prevWeekEndBar)
    int safe_prev_monday_start = na
    if not na(prevMondayStartBar) and bar_index - prevMondayStartBar >= 0
        safe_prev_monday_start := math.min(4900, math.max(0, bar_index - prevMondayStartBar))
    
    int safe_prev_week_end = na
    if not na(prevWeekEndBar) and bar_index - prevWeekEndBar >= 0
        safe_prev_week_end := math.min(4900, math.max(0, bar_index - prevWeekEndBar))
    
    if not na(safe_prev_monday_start) and not na(safe_prev_week_end)
        prevMondayStartTime := time[safe_prev_monday_start]
        prevWeekEndTime := time[safe_prev_week_end]
    
        if not na(prevMondayStartTime) and not na(prevWeekEndTime)
            prevMonHighLine := get_line_from_pool()
            prevMonHighLine.set_xy1(x=prevMondayStartTime, y=prevMondayHigh)
            prevMonHighLine.set_xy2(x=prevWeekEndTime, y=prevMondayHigh)
            prevMonHighLine.set_color(color=color_PrevMonday)
            prevMonHighLine.set_width(width=1)
            prevMonHighLine.set_style(style=line.style_dotted)
            
            prevMonLowLine := get_line_from_pool()
            prevMonLowLine.set_xy1(x=prevMondayStartTime, y=prevMondayLow)
            prevMonLowLine.set_xy2(x=prevWeekEndTime, y=prevMondayLow)
            prevMonLowLine.set_color(color=color_PrevMonday)
            prevMonLowLine.set_width(width=1)
            prevMonLowLine.set_style(style=line.style_dotted)
            prevMondayLinesDrawn := true

// Manage Current Monday lines
if isNewWeek and currentMondayLinesActive // Cleanup at the start of a new week
    if not na(currMonHighLine)
        return_line_to_pool(currMonHighLine)
        currMonHighLine := na
    if not na(currMonLowLine)
        return_line_to_pool(currMonLowLine)
        currMonLowLine := na
    lastPlottedMondayHigh := na
    lastPlottedMondayLow := na
    lastPlottedMondayStartTime := na
    currentMondayLinesActive := false

if barstate.islast
    if show_MondayRange and not na(mondayHigh) and not na(mondayLow) and not na(mondayStartBar)
        int mondayStartTimeValue = na
        int safe_monday_start_idx = na
        if bar_index - mondayStartBar >= 0
            safe_monday_start_idx := math.min(4900, math.max(0, bar_index - mondayStartBar))
            mondayStartTimeValue := time[safe_monday_start_idx]

        if not na(mondayStartTimeValue)
            if not currentMondayLinesActive // Create lines
                currMonHighLine := get_line_from_pool()
                currMonLowLine := get_line_from_pool()
                
                currMonHighLine.set_xy1(x=mondayStartTimeValue, y=mondayHigh)
                currMonHighLine.set_xy2(x=time, y=mondayHigh)
                currMonHighLine.set_color(color=color_CurrMonday)
                currMonHighLine.set_width(width=1)
                currMonHighLine.set_style(style=line.style_dotted)
                
                currMonLowLine.set_xy1(x=mondayStartTimeValue, y=mondayLow)
                currMonLowLine.set_xy2(x=time, y=mondayLow)
                currMonLowLine.set_color(color=color_CurrMonday)
                currMonLowLine.set_width(width=1)
                currMonLowLine.set_style(style=line.style_dotted)
                
                lastPlottedMondayHigh := mondayHigh
                lastPlottedMondayLow := mondayLow
                lastPlottedMondayStartTime := mondayStartTimeValue
                currentMondayLinesActive := true
            else // Lines exist, update them
                bool needsYUpdate = lastPlottedMondayHigh != mondayHigh or lastPlottedMondayLow != mondayLow
                bool needsX1Update = lastPlottedMondayStartTime != mondayStartTimeValue
                
                if needsX1Update
                    currMonHighLine.set_x1(x=mondayStartTimeValue)
                    currMonLowLine.set_x1(x=mondayStartTimeValue)
                    lastPlottedMondayStartTime := mondayStartTimeValue
                
                if needsYUpdate
                    currMonHighLine.set_y1(y=mondayHigh)
                    currMonHighLine.set_y2(y=mondayHigh)
                    currMonLowLine.set_y1(y=mondayLow)
                    currMonLowLine.set_y2(y=mondayLow)
                    lastPlottedMondayHigh := mondayHigh
                    lastPlottedMondayLow := mondayLow
                
                currMonHighLine.set_x2(x=time)
                currMonLowLine.set_x2(x=time)

    else if currentMondayLinesActive // show_MondayRange is false or not Monday anymore
        if not na(currMonHighLine)
            return_line_to_pool(currMonHighLine)
            currMonHighLine := na
        if not na(currMonLowLine)
            return_line_to_pool(currMonLowLine)
            currMonLowLine := na
        lastPlottedMondayHigh := na
        lastPlottedMondayLow := na
        lastPlottedMondayStartTime := na
        currentMondayLinesActive := false

// ==== Market Order Bubble Plotting ====

// --- æ¨¡å—ä¸€ï¼šç»˜åˆ¶Deltaæ–‡å­—æ ‡ç­¾ (ä¿æŒä¸å˜) ---
if showBubble and i_showBubbleText
    label textLabel = array.get(text_pool, text_pointer)
    string deltaText = str.tostring(netDelta, format.volume)
    
    float tr = ta.tr
    float y_offset = tr 
    float text_y_pos = deltaZscore > 0 ? high + y_offset : low - y_offset

    label.set_xy(textLabel, bar_index, text_y_pos)
    label.set_yloc(textLabel, yloc.price)
    label.set_text(textLabel, deltaText)
    label.set_textcolor(textLabel, color.new(color.white, 50))
    label.set_size(textLabel, size.tiny)
    label.set_style(textLabel, label.style_none)

    text_pointer := (text_pointer + 1) % i_maxBubbles

// --- æ¨¡å—äºŒï¼šä½¿ç”¨å¤šä¸ªplotshapeç»˜åˆ¶ä¸åŒå°ºå¯¸çš„å¤§æ°”æ³¡ (5ä¸ªå°ºå¯¸ç­‰çº§) ---

// 1. æ ¹æ®é»˜è®¤ f_getBubbleSize å‡½æ•°çš„é€»è¾‘ï¼Œè®¡ç®—å‡ºæ¯ä¸ªå°ºå¯¸çš„å¸ƒå°”æ¡ä»¶
//    æ³¨æ„ï¼š'showBubble' æ˜¯åŒ…å«äº†Z-Scoreé˜ˆå€¼çš„ä¸»å¼€å…³
bool is_tiny_size   = showBubble and math.abs(deltaZscore) < 3.5
bool is_small_size  = showBubble and math.abs(deltaZscore) >= 3.5 and math.abs(deltaZscore) < 4.3
bool is_normal_size = showBubble and math.abs(deltaZscore) >= 4.3 and math.abs(deltaZscore) < 4.5
bool is_large_size  = showBubble and math.abs(deltaZscore) >= 4.5 and math.abs(deltaZscore) < 5.0
bool is_huge_size   = showBubble and math.abs(deltaZscore) >= 5.0

// 2. å‡†å¤‡åŠ¨æ€é¢œè‰² (ä¿æŒä¸å˜)
color plot_color = na
if showBubble
    bubble_transparency = f_getBubbleTransparency(deltaZscore)
    base_color = deltaZscore > 0 ? i_buyBubbleColor : i_sellBubbleColor
    plot_color := color.new(base_color, bubble_transparency)

// 3. ä¸ºå…¨éƒ¨5ä¸ªå°ºå¯¸ç­‰çº§å’Œ2ä¸ªæ–¹å‘ï¼Œå•ç‹¬è°ƒç”¨ plotshape

// -- ç»˜åˆ¶ä¹°å…¥æ°”æ³¡ (5ä¸ªå°ºå¯¸ - ç¼©å°ç‰ˆ) --
plotshape(series=is_tiny_size and deltaZscore > 0,   title="Buy Bubble Tiny",   style=shape.circle, location=location.abovebar, color=plot_color, size=size.tiny)   // tiny -> tiny (æœ€å°)
plotshape(series=is_small_size and deltaZscore > 0,  title="Buy Bubble Small",  style=shape.circle, location=location.abovebar, color=plot_color, size=size.tiny)   // small -> tiny
plotshape(series=is_normal_size and deltaZscore > 0, title="Buy Bubble Normal", style=shape.circle, location=location.abovebar, color=plot_color, size=size.small)  // normal -> tiny
plotshape(series=is_large_size and deltaZscore > 0,  title="Buy Bubble Large",  style=shape.circle, location=location.abovebar, color=plot_color, size=size.small) // large -> small
plotshape(series=is_huge_size and deltaZscore > 0,   title="Buy Bubble Huge",   style=shape.circle, location=location.abovebar, color=plot_color, size=size.normal)  // huge -> normal

// -- ç»˜åˆ¶å–å‡ºæ°”æ³¡ (5ä¸ªå°ºå¯¸ - ç¼©å°ç‰ˆ) --
plotshape(series=is_tiny_size and deltaZscore < 0,   title="Sell Bubble Tiny",   style=shape.circle, location=location.belowbar, color=plot_color, size=size.tiny)   // tiny -> tiny (æœ€å°)
plotshape(series=is_small_size and deltaZscore < 0,  title="Sell Bubble Small",  style=shape.circle, location=location.belowbar, color=plot_color, size=size.tiny)   // small -> tiny
plotshape(series=is_normal_size and deltaZscore < 0, title="Sell Bubble Normal", style=shape.circle, location=location.belowbar, color=plot_color, size=size.small)  // normal -> tiny
plotshape(series=is_large_size and deltaZscore < 0,  title="Sell Bubble Large",  style=shape.circle, location=location.belowbar, color=plot_color, size=size.small) // large -> small
plotshape(series=is_huge_size and deltaZscore < 0,   title="Sell Bubble Huge",   style=shape.circle, location=location.belowbar, color=plot_color, size=size.normal)  // huge -> normal

// END OF SCRIPT
