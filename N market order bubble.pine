// @version=6
indicator(title='N', shorttitle='N', overlay=true, max_bars_back=4999, max_polylines_count=100, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// Import Professional Calculation Library
import PineCoders/ConditionalAverages/1 as pc

// =============================================================================
// ==== INPUTS ====
// =============================================================================

// Constants
var string FONT_MONO = font.family_monospace
var DEFAULT_LINE_STYLE = line.style_dotted
var PVWAP_LINE_STYLE = line.style_solid // Added new constant for pvwap and key level lines
var DEFAULT_LABEL_STYLE = label.style_label_left
var int KEYLEVEL_LINE_LENGTH = 3

// ==== Rolling VWAP Settings ====
group_rvwap = '滚动VWAP设置 (Rolling VWAP)'
show_7d = input.bool(true, '显示7天 (Show 7D)', group=group_rvwap)
show_30d = input.bool(true, '显示30天 (Show 30D)', group=group_rvwap)
show_90d = input.bool(true, '显示90天 (Show 90D)', group=group_rvwap)
show_365d = input.bool(true, '显示365天 (Show 365D)', group=group_rvwap)
color_7d = input.color(color.new(#6BEFF9, 40), '7D颜色 (Color)', group=group_rvwap, inline='7d')
color_30d = input.color(color.new(#00BED6, 40), '30D颜色 (Color)', group=group_rvwap, inline='30d')
color_90d = input.color(color.new(#006C7A, 40), '90D颜色 (Color)', group=group_rvwap, inline='90d')
color_365d = input.color(color.new(#004851, 40), '365D颜色 (Color)', group=group_rvwap, inline='365d')
rvwap_ref_tf = input.string('60', '参考时间框架 (Reference TF)', options=['5', '15', '60', '240', 'D'], group=group_rvwap, tooltip='用于计算滚动VWAP的参考时间框架')
rvwap_smoothing = input.int(1, '平滑周期 (Smoothing)', minval=1, maxval=100, group=group_rvwap, tooltip='滚动VWAP的平滑周期数')

// ==== Anchored VWAP Settings ====
VWAP_Ctl_Group = '锚定VWAP (Anchored VWAP)'
vwapSource = hlc3

// --- VWAP #1 (Defaults to Quarterly) ---
VWAP1_Settings = 'VWAP #1 Settings (Quarterly Default)'
VWAP1_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
Anchor1 = input.string(defval='Quarter', title='', group=VWAP_Ctl_Group, inline=VWAP1_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP1_Col = input.color(color.new(#7E57C2, 20), title='POC', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
Bands1_Col = input.color(color.new(#7E57C2, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP1_Settings)
VWAP1_Bgc = input.color(color.new(#7E57C2, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP1_Settings)

// --- VWAP #2 (Defaults to Monthly) ---
VWAP2_Settings = 'VWAP #2 Settings (Monthly Default)'
VWAP2_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
Anchor2 = input.string(defval='Month', title='', group=VWAP_Ctl_Group, inline=VWAP2_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP2_Col = input.color(color.new(#29B6F6, 20), title='POC', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
Bands2_Col = input.color(color.new(#29B6F6, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP2_Settings)
VWAP2_Bgc = input.color(color.new(#29B6F6, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP2_Settings)

// --- VWAP #3 (Defaults to Weekly) ---
VWAP3_Settings = 'VWAP #3 Settings (Weekly Default)'
VWAP3_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
Anchor3 = input.string(defval='Week', title='', group=VWAP_Ctl_Group, inline=VWAP3_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP3_Col = input.color(color.new(#FFCA28, 20), title='POC', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
Bands3_Col = input.color(color.new(#FFCA28, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP3_Settings)
VWAP3_Bgc = input.color(color.new(#FFCA28, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP3_Settings)

// --- VWAP #4 (Defaults to Daily) ---
VWAP4_Settings = 'VWAP #4 Settings (Daily Default)'
VWAP4_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
Anchor4 = input.string(defval='Day', title='', group=VWAP_Ctl_Group, inline=VWAP4_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP4_Col = input.color(color.new(#FFFFFF, 70), title='POC', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
Bands4_Col = input.color(color.new(#FFFFFF, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP4_Settings)
VWAP4_Bgc = input.color(color.new(#FFFFFF, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP4_Settings)

// --- VWAP #5 (Defaults to Yearly) ---
VWAP5_Settings = 'VWAP #5 Settings (Yearly Default)'
VWAP5_Ctl = input.bool(true, title='', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
Anchor5 = input.string(defval='Year', title='', group=VWAP_Ctl_Group, inline=VWAP5_Settings, options=['Day', 'Week', 'Month', 'Quarter', 'Year'])
VWAP5_Col = input.color(color.new(#BDBDBD, 10), title='POC', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
Bands5_Col = input.color(color.new(#BDBDBD, 100), title='Bands Border', group=VWAP_Ctl_Group, inline=VWAP5_Settings)
VWAP5_Bgc = input.color(color.new(#BDBDBD, 95), title='Fill', group=VWAP_Ctl_Group, inline=VWAP5_Settings)

// ==== Previous Period VWAP Settings ====
VWAP_KeyLevel_Grp = '前期VWAP关键水平 (Previous VWAP Key Level)'
use_adaptive_tf = input.bool(true, '使用自适应时间框架 (Use Adaptive TF)', group=VWAP_KeyLevel_Grp, tooltip="根据当前图表时间框架自动选择合适的锚定时间框架进行计算")
use_tf_consistent_pvwap = input.bool(true, '使用跨时间框架pVWAP (TF-Consistent pVWAP)', group=VWAP_KeyLevel_Grp, tooltip="使用一致的计算方法在所有时间框架下显示一致的pVWAP值")
show_pvwap_yearly = input.bool(true, "显示前期年度VWAP (Show Previous Yearly VWAP)", group=VWAP_KeyLevel_Grp, inline="pyVWAP")
color_pvwap_yearly = input.color(color.new(#BDBDBD, 30), "", group=VWAP_KeyLevel_Grp, inline="pyVWAP")
show_pvwap_quarterly = input.bool(true, "显示前期季度VWAP (Show Previous Quarterly VWAP)", group=VWAP_KeyLevel_Grp, inline="pqVWAP")
color_pvwap_quarterly = input.color(color.new(#7E57C2, 30), "", group=VWAP_KeyLevel_Grp, inline="pqVWAP")
show_pvwap_monthly = input.bool(true, "显示前期月度VWAP (Show Previous Monthly VWAP)", group=VWAP_KeyLevel_Grp, inline="pmVWAP")
color_pvwap_monthly = input.color(color.new(#29B6F6, 30), "", group=VWAP_KeyLevel_Grp, inline="pmVWAP")
show_pvwap_weekly = input.bool(true, "显示前期周度VWAP (Show Previous Weekly VWAP)", group=VWAP_KeyLevel_Grp, inline="pwVWAP")
color_pvwap_weekly = input.color(color.new(#FFCA28, 30), "", group=VWAP_KeyLevel_Grp, inline="pwVWAP")
label_color_setting = input.color(color.new(color.yellow, 100), 'pVWAP 标签背景 (Label BG)', group=VWAP_KeyLevel_Grp)
pvwap_offset = input.int(20, 'pVWAP 标签偏移 (Label Offset)', minval=1, group=VWAP_KeyLevel_Grp)
pvwap_format_level = input.string('#.####', 'pVWAP 价格格式 (Price Format)', group=VWAP_KeyLevel_Grp)

// ==== Key Open Level Settings ====
KeyOpen_Grp = '关键开盘价 (Key Open Levels)'
keylevel_offset = input.int(50, '开盘价 标签偏移 (Label Offset)', minval=1, group=KeyOpen_Grp, tooltip="Offset for Key Open labels, different from pVWAP offset.")
keylevel_format = input.string('#.####', '开盘价 价格格式 (Price Format)', group=KeyOpen_Grp)
use_ref_tf_for_opens = input.bool(true, '使用日线计算关键开盘价 (Use Daily for Key Opens)', group=KeyOpen_Grp, tooltip='开启后将使用日线数据来确保在所有时间框架下关键开盘价保持一致')
show_MonthlyOpen = input.bool(true, "月开盘价 (Monthly Open)", group=KeyOpen_Grp, inline="MO")
color_MonthlyOpen = input.color(color.new(#29B6F6, 30), "", group=KeyOpen_Grp, inline="MO")
show_YearlyOpen = input.bool(true, "年开盘价 (Yearly Open)", group=KeyOpen_Grp, inline="YO")
color_YearlyOpen = input.color(color.new(#BDBDBD, 30), "", group=KeyOpen_Grp, inline="YO")
show_WeeklyOpen = input.bool(true, "周开盘价 (Weekly Open)", group=KeyOpen_Grp, inline="WO")
color_WeeklyOpen = input.color(color.new(#FFCA28, 30), "", group=KeyOpen_Grp, inline="WO")
show_QuarterlyOpen = input.bool(true, "季开盘价 (Quarterly Open)", group=KeyOpen_Grp, inline="QO")
color_QuarterlyOpen = input.color(color.new(#7E57C2, 30), "", group=KeyOpen_Grp, inline="QO")
show_DailyOpen = input.bool(true, "日开盘价 (Daily Open)", group=KeyOpen_Grp, inline="DO")
color_DailyOpen = input.color(color.new(#FFFFFF, 30), "", group=KeyOpen_Grp, inline="DO")

// ==== Monday Range Settings ====
MondayRange_Grp = '周一区间 (Monday Range)'
show_MondayRange = input.bool(true, "显示周一区间 (Show Monday Range)", group=MondayRange_Grp)
color_PrevMonday = input.color(color.new(#757575, 30), "上周颜色 (Prev Week Color)", group=MondayRange_Grp, inline="MR1")
color_CurrMonday = input.color(color.new(#757575, 30), "本周颜色 (Curr Week Color)", group=MondayRange_Grp, inline="MR2")

// ==== Volume Profile Settings ====
group_vp = '成交量分布图 (Volume Profile)'
vp_enable = input.bool(true, '启用VP (Enable VP)', group = group_vp)
vp_show_profile = input.bool(true, '显示VP柱状图 (Show VP Histogram)', inline = 'VP_Display', tooltip = '是否显示成交量分布图的柱状图', group = group_vp)
vp_profile_color = input.color(color.new(#757575, 90), '', inline = 'VP_Display', group = group_vp)
vp_show_historical = input.bool(true, '显示历史VP (Show Historical VP)', inline = 'VP_History', tooltip = '是否显示历史成交量分布图', group = group_vp)
vp_historical_color = input.color(color.new(#757575, 90), '', inline = 'VP_History', group = group_vp)
// Value Area固定颜色设置为#78909C，不透明度20%
vp_value_area_color = color.new(#757575, 80)
vp_max_history = input.int(3, '历史VP数量 (Max History)', 1, 10, tooltip = '最大保存的历史VP数量', group = group_vp)
vp_show_poc = input.bool(true, '显示VPOC (Show VPOC)', inline = 'VPOC_Display', tooltip = '是否显示成交量控制点 (VPOC)', group = group_vp)
vp_poc_color = input.color(color.new(#00BCD4, 0), '', inline = 'VPOC_Display', group = group_vp)
vp_rows = input.int(200, '行数 (Rows)', 10, 500, tooltip = '用于构建成交量分布图的价格级别/行数', group = group_vp)
vp_profile_tf = input.timeframe('W', '分布图时间框架 (Profile Timeframe)', tooltip = '成交量分布图所代表的聚合时间框架', group = group_vp)
vp_resolution_tf = input.timeframe('3', '解析度时间框架 (Resolution Timeframe)', tooltip = '用于构建成交量分布图的更低级别时间框架数据', group = group_vp)
vp_extend_profile_percent = input.int(30, '分布图延伸 % (Profile Extend %)', 0, 100, tooltip = '成交量分布图应延伸到下一个周期的百分比', group = group_vp)
vp_label_offset_bars = input.int(5, 'VPOC标签偏移柱数 (VPOC Label Offset Bars)', 1, 100, group = group_vp, tooltip = '当前VPOC标签的柱偏移量')
vp_price_format = input.string('#.##', 'VPOC价格格式 (VPOC Price Format)', group = group_vp)

// ==== Market Order Bubble Settings ====
group_mob = '市价单气泡 (Market Order Bubbles)'
enable_mob = input.bool(true, '启用市价单气泡', group=group_mob)
mob_bubble_buy_color = input.color(color.new(#00ff00, 70), '买单气泡颜色', group=group_mob)
mob_bubble_sell_color = input.color(color.new(#ff0000, 70), '卖单气泡颜色', group=group_mob)
mob_threshold_multiplier = input.float(2.0, '阈值倍数', step=0.1, group=group_mob, tooltip='超过平均成交量的倍数')
mob_ma_length = input.int(20, '平均周期', group=group_mob)
mob_show_days = input.int(3, '显示天数', group=group_mob, tooltip='只显示最近几天的数据')
mob_show_text = input.bool(true, '显示倍数文本', group=group_mob, tooltip='在气泡中显示成交量倍数')
mob_use_transparency = input.bool(true, '使用动态透明度', group=group_mob, tooltip='根据订单大小调整透明度')

// =============================================================================
// ==== GLOBAL VARIABLE DECLARATIONS ====
// =============================================================================

var int cached_day = na
var int cached_month = na
var int cached_year = na
var int cached_quarter = na
var int cached_dayofweek = na
var int prev_bar_index = na
var bool is_new_day = false
var bool is_new_week = false
var bool is_new_month = false
var bool is_new_quarter = false
var bool is_new_year = false

var line[] line_pool = array.new_line()
var label[] label_pool = array.new_label()
var bool[] line_used_map = array.new_bool()
var bool[] label_used_map = array.new_bool()

initialize_object_pools() => // Function to initialize object pools
    if array.size(line_pool) == 0
        for i = 0 to 199
            line_obj = line.new(x1=0, y1=0, x2=0, y2=0, color=color.white, width=1, xloc=xloc.bar_time, style=DEFAULT_LINE_STYLE)
            array.push(line_pool, line_obj)
            array.push(line_used_map, false)
    if array.size(label_pool) == 0
        for i = 0 to 199
            label_obj = label.new(x=0, y=0, text="", color=color.white, textcolor=color.black, style=DEFAULT_LABEL_STYLE, xloc=xloc.bar_time, text_font_family=FONT_MONO)
            array.push(label_pool, label_obj)
            array.push(label_used_map, false)

get_line_from_pool() => // Function to get a line object from the pool
    initialize_object_pools()
    line result = na
    int pool_size = array.size(line_pool)
    
    // Simplified single linear scan
    for i = 0 to pool_size - 1
        if not array.get(line_used_map, i)
            array.set(line_used_map, i, true)
            result := array.get(line_pool, i)
            break
            
    if na(result) // If pool is exhausted, create a new one
        new_line = line.new(x1=0, y1=0, x2=0, y2=0, color=color.white, width=1, xloc=xloc.bar_time, style=DEFAULT_LINE_STYLE)
        array.push(line_pool, new_line)
        array.push(line_used_map, true)
        result := new_line
    result

get_label_from_pool() => // Function to get a label object from the pool
    initialize_object_pools()
    label result = na
    int pool_size = array.size(label_pool)

    // Simplified single linear scan
    for i = 0 to pool_size - 1
        if not array.get(label_used_map, i)
            array.set(label_used_map, i, true)
            result := array.get(label_pool, i)
            break
            
    if na(result) // If pool is exhausted, create a new one
        new_label = label.new(x=0, y=0, text="", color=color.white, textcolor=color.black, style=DEFAULT_LABEL_STYLE, xloc=xloc.bar_time, text_font_family=FONT_MONO)
        array.push(label_pool, new_label)
        array.push(label_used_map, true)
        result := new_label
    result

return_line_to_pool(line_obj) => 
    bool _return = false 
    if not na(line_obj)
        int pool_size = array.size(line_pool)
        // 修复：使用正序扫描替代负步长
        for i = 0 to pool_size - 1
            if array.get(line_pool, i) == line_obj
                array.set(line_used_map, i, false)
                _return := true
                break
    _return


return_label_to_pool(label_obj) => 
    bool _return = false 
    if not na(label_obj)
        int pool_size = array.size(label_pool)
        // 修复：使用正序扫描替代负步长
        for i = 0 to pool_size - 1
            if array.get(label_pool, i) == label_obj
                array.set(label_used_map, i, false)
                _return := true
                break
    _return


var label[] key_open_labels = array.new_label()
var label[] pvwap_labels = array.new_label()
var line[] key_open_lines = array.new_line()
var line[] pvwap_lines = array.new_line()

var float cache_yearlyOpen = na
var float cache_monthlyOpen = na
var float cache_weeklyOpen = na
var float cache_quarterlyOpen = na
var float cache_dailyOpen = na
var float cache_lastWeeklyPOC = na
var float cache_lastMonthlyPOC = na
var float cache_lastQuarterlyPOC = na
var float cache_lastYearlyPOC = na

var int thisWeekStart = na
var float lastWeeklyLower = na
var float lastWeeklyUpper = na
var float lastWeeklyPOC = na
var int thisMonthStart = na
var float lastMonthlyLower = na
var float lastMonthlyUpper = na
var float lastMonthlyPOC = na
var int thisQuarterStart = na
var float lastQuarterlyLower = na
var float lastQuarterlyUpper = na
var float lastQuarterlyPOC = na
var int thisYearStart = na
var float lastYearlyLower = na
var float lastYearlyUpper = na
var float lastYearlyPOC = na

var float monthlyOpen = na
var float yearlyOpen = na
var float weeklyOpen = na
var float quarterlyOpen = na
var float dailyOpen = na

var float mondayHigh = na
var float mondayLow = na
var int mondayStartBar = na
var int mondayEndBar = na
var float prevMondayHigh = na
var float prevMondayLow = na
var int prevMondayStartBar = na
var int prevWeekEndBar = na

var int prevMondayStartTime = na  
var int prevWeekEndTime = na     

// Volume Profile Global Variables
var array<line> vp_historical_pocs = array.new_line() // Stores historical VPOC lines
var array<polyline> vp_historical_profiles = array.new<polyline>(0) // 存储历史VP图形
var array<polyline> vp_historical_value_areas = array.new<polyline>(0) // 存储历史VP的Value Area
var int max_historical_profiles = 5 // 最大保存的历史VP图形数量

// 在全局变量区域预分配数组
var float[] vp_volume_values = array.new_float(0)
var float[] vp_y_coords = array.new_float(0)
var int[] vp_x_coords = array.new_int(0)

// 初始化时预填充数组
if array.size(vp_volume_values) != vp_rows
    array.clear(vp_volume_values)
    array.clear(vp_y_coords)
    array.clear(vp_x_coords)
    for i = 0 to vp_rows - 1
        array.push(vp_volume_values, 0.0)
        array.push(vp_y_coords, 0.0)
        array.push(vp_x_coords, 0)

var array<chart.point> vp_profile_points_array = array.new<chart.point>() // Stores points for drawing the polyline
var array<chart.point> vp_value_area_points_array = array.new<chart.point>() // Stores points for drawing value area
var polyline vp_current_profile_polyline = na        // The current volume profile polyline
var polyline vp_current_value_area_polyline = na     // The current value area polyline
var line vp_current_poc_main_line = na            // Line for the current VPOC (from profile start to current bar)
var line vp_current_poc_label_line = na           // Short line segment for the current VPOC label
var label vp_current_poc_label = na               // Label for the current VPOC
var int vp_last_bar_idx_profile_start = na        // Bar index at the start of the current VP period
var int vp_last_time_profile_start = na           // Time at the start of the current VP period
var float vp_last_profile_low = na                // 保存上一个周期的最低价格
var float vp_last_profile_high = na               // 保存上一个周期的最高价格
var int vp_value_area_low_idx = na                // Value Area的下界索引
var int vp_value_area_high_idx = na               // Value Area的上界索引


get_quarter(t) => // Function to get the quarter of a given time
    m = month(t)
    (m <= 3) ? 1 : (m <= 6) ? 2 : (m <= 9) ? 3 : 4

// =============================================================================
// ==== FUNCTIONS ====
// =============================================================================

// ==== Market Order Bubble Functions ====
// 估算买卖成交量
estimate_buy_sell_volume() =>
    // 简化的买卖成交量估算
    body_ratio = math.abs(close - open) / (high - low)
    body_ratio := na(body_ratio) ? 0 : body_ratio
    
    // 声明变量
    var float buy_volume = 0.0
    var float sell_volume = 0.0
    
    // 根据K线方向和实体大小分配成交量
    if close > open // 阳线
        buy_volume := volume * (0.5 + body_ratio * 0.5)
        sell_volume := volume * (0.5 - body_ratio * 0.3)
    else if close < open // 阴线
        buy_volume := volume * (0.5 - body_ratio * 0.3)
        sell_volume := volume * (0.5 + body_ratio * 0.5)
    else // 十字星
        buy_volume := volume * 0.5
        sell_volume := volume * 0.5
    
    [buy_volume, sell_volume]

// 根据成交量比例计算透明度
get_bubble_transparency(volume_ratio) =>
    // 成交量越大，透明度越低（越不透明）
    if volume_ratio < 1.5
        90 // 很透明
    else if volume_ratio < 2.0
        80
    else if volume_ratio < 3.0
        70
    else if volume_ratio < 5.0
        60
    else
        50 // 不透明

// 检测市价单气泡
detect_market_order_bubbles() =>
    // 声明返回变量
    var bool is_large_buy = false
    var bool is_large_sell = false
    var float buy_vol = 0.0
    var float sell_vol = 0.0
    var float buy_ratio = 0.0
    var float sell_ratio = 0.0
    var int buy_transp = 90
    var int sell_transp = 90
    
    // 只在15分钟及以下时间框架显示
    if timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds('15')
        // 只显示指定天数以内的数据
        max_bars_back = mob_show_days * 24 * 4 // 假设15分钟K线：3天*24小时*4根/小时
        if bar_index >= max_bars_back
            [buy_vol_temp, sell_vol_temp] = estimate_buy_sell_volume()
            buy_vol := buy_vol_temp
            sell_vol := sell_vol_temp
            
            // 计算平均成交量
            avg_volume = ta.sma(volume, mob_ma_length)
            
            // 计算阈值
            volume_threshold = avg_volume * mob_threshold_multiplier
            
            // 检测买单和卖单
            is_large_buy := buy_vol > volume_threshold
            is_large_sell := sell_vol > volume_threshold
            
            // 计算成交量比例（相对于阈值）
            buy_ratio := is_large_buy ? buy_vol / volume_threshold : 0
            sell_ratio := is_large_sell ? sell_vol / volume_threshold : 0
            
            // 计算透明度
            if is_large_buy and mob_use_transparency
                buy_transp := get_bubble_transparency(buy_ratio)
            
            if is_large_sell and mob_use_transparency
                sell_transp := get_bubble_transparency(sell_ratio)
    
    [is_large_buy, is_large_sell, buy_vol, sell_vol, buy_ratio, sell_ratio, buy_transp, sell_transp]

detect_timeframe_changes() => // Function to detect timeframe changes
    current_day = dayofmonth(time)
    current_month = month(time)
    current_year = year(time)
    current_quarter = get_quarter(time)
    current_dayofweek = dayofweek(time)
    isNewDay = current_day != cached_day or current_month != cached_month
    isNewWeek = current_dayofweek == dayofweek.monday and cached_dayofweek != dayofweek.monday
    isNewMonth = current_month != cached_month
    isNewQuarter = current_quarter != cached_quarter
    isNewYear = current_year != cached_year
    [isNewDay, isNewWeek, isNewMonth, isNewQuarter, isNewYear, current_day, current_month, current_year, current_quarter, current_dayofweek]

get_adaptive_anchor_tf(vwap_type='default') => // Function to get adaptive anchor timeframe
    current_tf = timeframe.period
    if vwap_type == 'yearly' or vwap_type == 'pyvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15" or current_tf == "30" or current_tf == "45" or current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "60"
    else if vwap_type == 'quarterly' or vwap_type == 'pqvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15" or current_tf == "30" or current_tf == "45" or current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "45"
    else if vwap_type == 'monthly' or vwap_type == 'pmvwap'
        if current_tf == "1" or current_tf == "3" or current_tf == "5" or current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "30"
    else if vwap_type == 'weekly' or vwap_type == 'pwvwap'
        if current_tf == "1" or current_tf == "3"
            "3"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240" or current_tf == "D" or current_tf == "W"
            "240"
        else
            "15"
    else if vwap_type == 'daily'
        if current_tf == "1"
            "1"
        else if current_tf == "3"
            "3"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240" or current_tf == "D" or current_tf == "W" or current_tf == "M"
            "240"
        else
            "15"
    else // default
        if current_tf == "1" or current_tf == "3"
            "5"
        else if current_tf == "5"
            "5"
        else if current_tf == "15"
            "15"
        else if current_tf == "30"
            "30"
        else if current_tf == "45"
            "45"
        else if current_tf == "60"
            "60"
        else if current_tf == "120"
            "120"
        else if current_tf == "180"
            "180"
        else if current_tf == "240"
            "240"
        else if current_tf == "D" or current_tf == "W" or current_tf == "M"
            "D"
        else
            "D"

f_rolling_vwap(days) => // Function to calculate rolling VWAP
    time_window = days * 24 * 60 * 60 * 1000
    sum_src_vol = pc.totalForTimeWhen(vwapSource * volume, time_window, true, 10)
    sum_vol = pc.totalForTimeWhen(volume, time_window, true, 10)
    sum_vol == 0 ? na : sum_src_vol / sum_vol

f_rolling_vwap_for_small_tf(days, ref_tf) => // Function to calculate rolling VWAP for small timeframes
    request.security(syminfo.tickerid, ref_tf, f_rolling_vwap(days))

f_is_new_period(anchor) => // Function to check if it's a new period for anchored VWAP
    anchor_tf = switch anchor
        'Day'     => 'D'
        'Week'    => 'W'
        'Month'   => 'M'
        'Quarter' => '3M'
        'Year'    => '12M'
        => '' // Default case
    anchor_tf == '' ? false : timeframe.change(anchor_tf)


calculate_basic_vwap(src, reset_condition) => // Function to calculate basic VWAP and bands
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    [_vwap, _stdev_upper_band, _] = ta.vwap(src, reset_condition, 1)
    if not na(_vwap)
        vwapValue := _vwap
        if not na(_stdev_upper_band)
            stdev_abs = _stdev_upper_band - vwapValue
            upperBand := vwapValue + stdev_abs
            lowerBand := vwapValue - stdev_abs
        else
            upperBand := na
            lowerBand := na
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap_native(src, is_active, is_new_period) => // Function to calculate current VWAP natively
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    if is_active and not timeframe.isdwm
        [_vwap, _stdev_upper_band, _] = ta.vwap(src, is_new_period, 1)
        if not na(_vwap)
            vwapValue := _vwap
            if not na(_stdev_upper_band)
                stdev_abs = _stdev_upper_band - vwapValue
                upperBand := vwapValue + stdev_abs
                lowerBand := vwapValue - stdev_abs
            else
                upperBand := na
                lowerBand := na
        else
            vwapValue := na
            upperBand := na
            lowerBand := na
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap_adaptive(src, is_active, anchor_period) => // Function to calculate current VWAP adaptively
    float vwapValue = na
    float upperBand = na
    float lowerBand = na
    if is_active
        string vwap_type = 'default'
        if anchor_period == 'Year'
            vwap_type := 'yearly'
        else if anchor_period == 'Quarter'
            vwap_type := 'quarterly'
        else if anchor_period == 'Month'
            vwap_type := 'monthly'
        else if anchor_period == 'Week'
            vwap_type := 'weekly'
        else if anchor_period == 'Day'
            vwap_type := 'daily'
        ref_tf = get_adaptive_anchor_tf(vwap_type)
        isWeekStart = dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday)
        isMonthStart = month(time) != month(time[1])
        isQuarterStart = get_quarter(time) != get_quarter(time[1])
        isYearStart = year(time) != year(time[1])
        isDayStart = dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1])
        period_start_condition = anchor_period == 'Week' ? isWeekStart : anchor_period == 'Month' ? isMonthStart : anchor_period == 'Quarter' ? isQuarterStart : anchor_period == 'Year' ? isYearStart : anchor_period == 'Day' ? isDayStart : true
        reset_condition = request.security(syminfo.tickerid, ref_tf, period_start_condition, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
        [vwap_value_sec, upper_band_sec, lower_band_sec] = request.security(syminfo.tickerid, ref_tf, calculate_basic_vwap(src, reset_condition), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
        vwapValue := vwap_value_sec
        upperBand := upper_band_sec
        lowerBand := lower_band_sec
    [vwapValue, upperBand, lowerBand]

f_calculate_current_vwap(src, is_active, is_new_period_val, anchor_type) => // Unified function to calculate current VWAP
    if anchor_type == 'Day' and not use_adaptive_tf
        f_calculate_current_vwap_native(src, is_active, is_new_period_val)
    else
        f_calculate_current_vwap_adaptive(src, is_active, anchor_type)

get_fixed_tf_vwap(src, period_type) => // Function to get VWAP for a fixed timeframe
    string vwap_type = 'default'
    if period_type == 'Y'
        vwap_type := 'pyvwap'
    else if period_type == 'Q'
        vwap_type := 'pqvwap'
    else if period_type == 'M'
        vwap_type := 'pmvwap'
    else if period_type == 'W'
        vwap_type := 'pwvwap'
    else if period_type == 'D'
        vwap_type := 'daily'
    ref_tf = get_adaptive_anchor_tf(vwap_type)
    reset_condition_sec = request.security(syminfo.tickerid, ref_tf, period_type == 'W' ? dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday) : period_type == 'M' ? month(time) != month(time[1]) : period_type == 'Q' ? get_quarter(time) != get_quarter(time[1]) : period_type == 'Y' ? year(time) != year(time[1]) : period_type == 'D' ? dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1]) : false, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    [vwap_value_sec, upper_band_sec, lower_band_sec] = request.security(syminfo.tickerid, ref_tf, calculate_basic_vwap(src, reset_condition_sec), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
    [vwap_value_sec, upper_band_sec, lower_band_sec]

calculate_period_vwap(src, tf_string) => // Function to calculate period VWAP
    isNewPeriod = timeframe.change(tf_string)
    [vwapVal, upperVal, lowerVal] = calculate_basic_vwap(src, isNewPeriod)
    [vwapVal, upperVal, lowerVal]

detect_period_change(period) => // Function to detect period change
    switch period
        'W' => dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday)
        'M' => month(time) != month(time[1])
        'Q' => get_quarter(time) != get_quarter(time[1])
        'Y' => year(time) != year(time[1])
        => false

calculate_and_store_previous_vwap(period) => // Function to calculate and store previous period VWAP
    is_tf_change = detect_period_change(period)
    float poc = na
    float upper = na
    float lower = na
    int start_index = na
    [cur_poc, cur_upper, cur_lower] = get_fixed_tf_vwap(vwapSource, period)
    if is_tf_change
        poc := cur_poc[1]
        upper := cur_upper[1]
        lower := cur_lower[1]
        start_index := bar_index
    [poc, upper, lower, start_index]

plot_previous_vwap_levels(anchor_str, p_upper, p_lower, p_poc, p_start_bar, vwap_plot_color) => // Function to plot previous VWAP levels
    if not na(p_poc) and not na(p_start_bar)
        int offset_time = time + (pvwap_offset * timeframe.in_seconds(timeframe.period) * 1000) 
        int line_start_time = offset_time - (KEYLEVEL_LINE_LENGTH * timeframe.in_seconds(timeframe.period) * 1000) 
        color labelTextColor = color.new(vwap_plot_color, 45)
        color shortLineColor = color.new(vwap_plot_color, 30)
        string lower_label_text = ""
        string poc_label_text = ""
        string upper_label_text = ""
        if anchor_str == 'Week'
            lower_label_text := "pWvaL"
            poc_label_text := "pWvwap"
            upper_label_text := "pWvaH"
        else if anchor_str == 'Month'
            lower_label_text := "pMvaL"
            poc_label_text := "pMvwap"
            upper_label_text := "pMvaH"
        else if anchor_str == 'Quarter'
            lower_label_text := "pQvaL"
            poc_label_text := "pQvwap"
            upper_label_text := "pQvaH"
        else if anchor_str == 'Year'
            lower_label_text := "pYvaL"
            poc_label_text := "pYvwap"
            upper_label_text := "pYvaH"
        else
            prefix = switch anchor_str
                'Week'    => 'pw'
                'Month'   => 'pm'
                'Quarter' => 'pq'
                'Year'    => 'py'
                => 'p'
            lower_label_text := prefix + 'VWAP -1'
            poc_label_text := prefix + 'VWAP'
            upper_label_text := prefix + 'VWAP +1'
        if not na(p_lower)
            line_lower = get_line_from_pool()
            line_lower.set_xy1(line_start_time, p_lower)
            line_lower.set_xy2(offset_time, p_lower)
            line_lower.set_color(shortLineColor)
            line_lower.set_width(1)
            line_lower.set_style(PVWAP_LINE_STYLE)
            array.push(pvwap_lines, line_lower)
            lbl_lower = get_label_from_pool()
            lbl_lower.set_xy(offset_time, p_lower)
            lbl_lower.set_text(lower_label_text)
            lbl_lower.set_tooltip(str.tostring(p_lower, pvwap_format_level))
            lbl_lower.set_color(label_color_setting)
            lbl_lower.set_textcolor(labelTextColor)
            lbl_lower.set_style(DEFAULT_LABEL_STYLE)
            lbl_lower.set_text_font_family(FONT_MONO)
            array.push(pvwap_labels, lbl_lower)
        if not na(p_upper)
            line_upper = get_line_from_pool()
            line_upper.set_xy1(line_start_time, p_upper)
            line_upper.set_xy2(offset_time, p_upper)
            line_upper.set_color(shortLineColor)
            line_upper.set_width(1)
            line_upper.set_style(PVWAP_LINE_STYLE)
            array.push(pvwap_lines, line_upper)
            lbl_upper = get_label_from_pool()
            lbl_upper.set_xy(offset_time, p_upper)
            lbl_upper.set_text(upper_label_text)
            lbl_upper.set_tooltip(str.tostring(p_upper, pvwap_format_level))
            lbl_upper.set_color(label_color_setting)
            lbl_upper.set_textcolor(labelTextColor)
            lbl_upper.set_style(DEFAULT_LABEL_STYLE)
            lbl_upper.set_text_font_family(FONT_MONO)
            array.push(pvwap_labels, lbl_upper)
        line_poc = get_line_from_pool()
        line_poc.set_xy1(line_start_time, p_poc)
        line_poc.set_xy2(offset_time, p_poc)
        line_poc.set_color(shortLineColor)
        line_poc.set_width(1)
        line_poc.set_style(PVWAP_LINE_STYLE)
        array.push(pvwap_lines, line_poc)
        lbl_poc = get_label_from_pool()
        lbl_poc.set_xy(offset_time, p_poc)
        lbl_poc.set_text(poc_label_text)
        lbl_poc.set_tooltip(str.tostring(p_poc, pvwap_format_level))
        lbl_poc.set_color(label_color_setting)
        lbl_poc.set_textcolor(labelTextColor)
        lbl_poc.set_style(DEFAULT_LABEL_STYLE)
        lbl_poc.set_text_font_family(FONT_MONO)
        array.push(pvwap_labels, lbl_poc)

plot_key_open_level(levelValue, levelName, levelColor, offset_val, format_str) => // Function to plot key open levels
    if not na(levelValue)
        int offset_time = time + (offset_val * timeframe.in_seconds(timeframe.period) * 1000) 
        int line_start_time = offset_time - (KEYLEVEL_LINE_LENGTH * timeframe.in_seconds(timeframe.period) * 1000) 
        color lineColor = levelColor
        color bgColor = label_color_setting
        color labelTextColor = switch levelName
            "YO" => color.new(#BDBDBD, 45)
            "QO" => color.new(#7E57C2, 45)
            "MO" => color.new(#29B6F6, 45)
            "WO" => color.new(#FFCA28, 45)
            "DO" => color.new(#FFFFFF, 45)
            => color.new(levelColor, 45)
        line_obj = get_line_from_pool()
        line_obj.set_xy1(line_start_time, levelValue)
        line_obj.set_xy2(offset_time, levelValue)
        line_obj.set_color(lineColor)
        line_obj.set_width(1)
        line_obj.set_style(PVWAP_LINE_STYLE)
        array.push(key_open_lines, line_obj)
        label_obj = get_label_from_pool()
        label_obj.set_xy(offset_time, levelValue)
        label_obj.set_text(levelName)
        label_obj.set_tooltip(str.tostring(levelValue, format_str))
        label_obj.set_color(bgColor)
        label_obj.set_textcolor(labelTextColor)
        label_obj.set_style(DEFAULT_LABEL_STYLE)
        label_obj.set_text_font_family(FONT_MONO)
        array.push(key_open_labels, label_obj)

f_get_yearly_open() => // Function to get yearly open price
    var float yo = na
    if year(time) != year(time[1]) or na(yo)
        yo := open
    yo

f_get_monthly_open() => // Function to get monthly open price
    var float mo = na
    if month(time) != month(time[1]) or na(mo)
        mo := open
    mo

f_get_quarterly_open() => // Function to get quarterly open price
    var float qo = na
    if get_quarter(time) != get_quarter(time[1]) or na(qo)
        qo := open
    qo

f_get_weekly_open() => // Function to get weekly open price
    var float wo = na
    if dayofweek(time) == dayofweek.monday and (dayofweek(time[1]) != dayofweek.monday or na(wo))
        wo := open
    wo

f_get_daily_open() => // Function to get daily open price
    var float d_open = na
    if dayofmonth(time) != dayofmonth(time[1]) or month(time) != month(time[1]) or na(d_open)
        d_open := open
    d_open

// 合并所有开盘价请求到一个request.security调用
yearOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_yearly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
monthOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_monthly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
quarterOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_quarterly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
weekOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_weekly_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na
dailyOpen_ref = use_ref_tf_for_opens ? request.security(syminfo.tickerid, "D", f_get_daily_open(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) : na

// =============================================================================
// ==== CALCULATIONS (Main Script Logic) ====
// =============================================================================

// ==== Market Order Bubble Calculations ====
[is_large_buy, is_large_sell, buy_vol, sell_vol, buy_ratio, sell_ratio, buy_transp, sell_transp] = detect_market_order_bubbles()

// 计算绘图条件（全局作用域）
avg_volume = ta.sma(volume, mob_ma_length)
volume_threshold = avg_volume * mob_threshold_multiplier

// 计算不同大小的绘图条件
plot_buy_bubble_tiny = enable_mob and is_large_buy and buy_ratio < 1.5
plot_buy_bubble_small = enable_mob and is_large_buy and buy_ratio >= 1.5 and buy_ratio < 2.0
plot_buy_bubble_normal = enable_mob and is_large_buy and buy_ratio >= 2.0 and buy_ratio < 3.0
plot_buy_bubble_large = enable_mob and is_large_buy and buy_ratio >= 3.0 and buy_ratio < 5.0
plot_buy_bubble_huge = enable_mob and is_large_buy and buy_ratio >= 5.0

plot_sell_bubble_tiny = enable_mob and is_large_sell and sell_ratio < 1.5
plot_sell_bubble_small = enable_mob and is_large_sell and sell_ratio >= 1.5 and sell_ratio < 2.0
plot_sell_bubble_normal = enable_mob and is_large_sell and sell_ratio >= 2.0 and sell_ratio < 3.0
plot_sell_bubble_large = enable_mob and is_large_sell and sell_ratio >= 3.0 and sell_ratio < 5.0
plot_sell_bubble_huge = enable_mob and is_large_sell and sell_ratio >= 5.0

// 计算颜色
buy_color = enable_mob and is_large_buy ? color.new(#00ff00, buy_transp) : na
sell_color = enable_mob and is_large_sell ? color.new(#ff0000, sell_transp) : na

[isNewDay, isNewWeek, isNewMonth, isNewQuarter, isNewYear, current_day, current_month, current_year, current_quarter, current_dayofweek] = detect_timeframe_changes()

cached_day := current_day
cached_month := current_month
cached_year := current_year
cached_quarter := current_quarter
cached_dayofweek := current_dayofweek

bool is_small_tf = timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds("60") 
rvwap_7d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(7, rvwap_ref_tf) : f_rolling_vwap(7)
rvwap_30d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(30, rvwap_ref_tf) : f_rolling_vwap(30)
rvwap_90d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(90, rvwap_ref_tf) : f_rolling_vwap(90)
rvwap_365d_raw = is_small_tf ? f_rolling_vwap_for_small_tf(365, rvwap_ref_tf) : f_rolling_vwap(365)

rvwap_7d = ta.sma(rvwap_7d_raw, rvwap_smoothing)
rvwap_30d = ta.sma(rvwap_30d_raw, rvwap_smoothing)
rvwap_90d = ta.sma(rvwap_90d_raw, rvwap_smoothing)
rvwap_365d = ta.sma(rvwap_365d_raw, rvwap_smoothing)

[vwap1, band1_upper, band1_lower] = f_calculate_current_vwap(vwapSource, VWAP1_Ctl, f_is_new_period(Anchor1), Anchor1)
[vwap2, band2_upper, band2_lower] = f_calculate_current_vwap(vwapSource, VWAP2_Ctl, f_is_new_period(Anchor2), Anchor2)
[vwap3, band3_upper, band3_lower] = f_calculate_current_vwap(vwapSource, VWAP3_Ctl, f_is_new_period(Anchor3), Anchor3)

string curr_tf_period = timeframe.period
int current_tf_seconds_val = timeframe.in_seconds(timeframe.period) 

int SECONDS_4H_VAL = 4 * 60 * 60
int SECONDS_12H_VAL = 12 * 60 * 60
int SECONDS_1D_VAL = 24 * 60 * 60
int SECONDS_1W_VAL = 7 * 24 * 60 * 60

bool is_4h_or_higher_tf = current_tf_seconds_val >= SECONDS_4H_VAL
bool is_12h_or_higher_tf = current_tf_seconds_val >= SECONDS_12H_VAL
bool is_weekly_or_higher_tf = current_tf_seconds_val >= SECONDS_1W_VAL
bool is_monthly_or_higher_tf = curr_tf_period == "M" or curr_tf_period == "3M" or curr_tf_period == "6M" or curr_tf_period == "12M"

[vwap4, band4_upper, band4_lower] = f_calculate_current_vwap(vwapSource, VWAP4_Ctl, f_is_new_period(Anchor4), Anchor4)
[vwap5, band5_upper, band5_lower] = f_calculate_current_vwap(vwapSource, VWAP5_Ctl, f_is_new_period(Anchor5), Anchor5)

[yearly_period_vwap, yearly_period_upper, yearly_period_lower] = calculate_period_vwap(vwapSource, '12M')
[quarterly_period_vwap, quarterly_period_upper, quarterly_period_lower] = calculate_period_vwap(vwapSource, '3M')
[monthly_period_vwap, monthly_period_upper, monthly_period_lower] = calculate_period_vwap(vwapSource, 'M')
[weekly_period_vwap, weekly_period_upper, weekly_period_lower] = calculate_period_vwap(vwapSource, 'W')

[yearly_poc_val, yearly_upper_val, yearly_lower_val, yearly_start_val] = calculate_and_store_previous_vwap('Y')
[quarterly_poc_val, quarterly_upper_val, quarterly_lower_val, quarterly_start_val] = calculate_and_store_previous_vwap('Q')
[monthly_poc_val, monthly_upper_val, monthly_lower_val, monthly_start_val] = calculate_and_store_previous_vwap('M')
[weekly_poc_val, weekly_upper_val, weekly_lower_val, weekly_start_val] = calculate_and_store_previous_vwap('W')


if not na(weekly_poc_val) and not na(weekly_start_val)
    lastWeeklyPOC := weekly_poc_val
    lastWeeklyUpper := weekly_upper_val
    lastWeeklyLower := weekly_lower_val
    thisWeekStart := int(weekly_start_val)
else if isNewWeek
    lastWeeklyLower := weekly_period_lower[1]
    lastWeeklyUpper := weekly_period_upper[1]
    lastWeeklyPOC := weekly_period_vwap[1]
    thisWeekStart := bar_index

if not na(monthly_poc_val) and not na(monthly_start_val)
    lastMonthlyPOC := monthly_poc_val
    lastMonthlyUpper := monthly_upper_val
    lastMonthlyLower := monthly_lower_val
    thisMonthStart := int(monthly_start_val)
else if isNewMonth
    lastMonthlyLower := monthly_period_lower[1]
    lastMonthlyUpper := monthly_period_upper[1]
    lastMonthlyPOC := monthly_period_vwap[1]
    thisMonthStart := bar_index

if not na(quarterly_poc_val) and not na(quarterly_start_val)
    lastQuarterlyPOC := quarterly_poc_val
    lastQuarterlyUpper := quarterly_upper_val
    lastQuarterlyLower := quarterly_lower_val
    thisQuarterStart := int(quarterly_start_val)
else if isNewQuarter
    lastQuarterlyLower := quarterly_period_lower[1]
    lastQuarterlyUpper := quarterly_period_upper[1]
    lastQuarterlyPOC := quarterly_period_vwap[1]
    thisQuarterStart := bar_index

if not na(yearly_poc_val) and not na(yearly_start_val)
    lastYearlyPOC := yearly_poc_val
    lastYearlyUpper := yearly_upper_val
    lastYearlyLower := yearly_lower_val
    thisYearStart := int(yearly_start_val)
else if isNewYear
    lastYearlyLower := yearly_period_lower[1]
    lastYearlyUpper := yearly_period_upper[1]
    lastYearlyPOC := yearly_period_vwap[1]
    thisYearStart := bar_index

bool valid_yearOpen_val = not na(yearOpen_ref) and yearOpen_ref > 0
bool valid_monthOpen_val = not na(monthOpen_ref) and monthOpen_ref > 0
bool valid_weekOpen_val = not na(weekOpen_ref) and weekOpen_ref > 0
bool valid_quarterOpen_val = not na(quarterOpen_ref) and quarterOpen_ref > 0
bool valid_dailyOpen_val = not na(dailyOpen_ref) and dailyOpen_ref > 0

if isNewMonth or na(monthlyOpen[1])
    monthlyOpen := valid_monthOpen_val and use_ref_tf_for_opens ? monthOpen_ref : open
if isNewYear or na(yearlyOpen[1])
    yearlyOpen := valid_yearOpen_val and use_ref_tf_for_opens ? yearOpen_ref : open
if isNewWeek or na(weeklyOpen[1])
    weeklyOpen := valid_weekOpen_val and use_ref_tf_for_opens ? weekOpen_ref : open
if isNewQuarter or na(quarterlyOpen[1])
    quarterlyOpen := valid_quarterOpen_val and use_ref_tf_for_opens ? quarterOpen_ref : open 
if isNewDay or na(dailyOpen[1])
    dailyOpen := valid_dailyOpen_val and use_ref_tf_for_opens ? dailyOpen_ref : open

bool isMondayNow = dayofweek(time) == dayofweek.monday
if isNewWeek
    prevMondayHigh := mondayHigh
    prevMondayLow := mondayLow
    prevMondayStartBar := mondayStartBar
    prevWeekEndBar := bar_index[1]
    mondayHigh := na
    mondayLow := na
    mondayStartBar := na
    mondayEndBar := na
    if not na(mondayStartBar) and (bar_index - mondayStartBar >=0) 
        prevMondayStartTime := time[bar_index - mondayStartBar] 
    else
        prevMondayStartTime := na 
    prevWeekEndTime := time[1]  
if isMondayNow
    if na(mondayStartBar)
        mondayStartBar := bar_index
        mondayHigh := high
        mondayLow := low
    else
        mondayHigh := math.max(na(mondayHigh) ? high : mondayHigh, high)
        mondayLow := math.min(na(mondayLow) ? low : mondayLow, low)
    mondayEndBar := bar_index

// ---- Volume Profile Calculations ----
if vp_enable
    vp_res_tf_str = timeframe.in_seconds(vp_resolution_tf) <= timeframe.in_seconds() ? vp_resolution_tf : timeframe.period
    [ltf_H_arr, ltf_L_arr, ltf_V_arr] = request.security_lower_tf(syminfo.tickerid, vp_res_tf_str, [high, low, volume])

    // 更新最大历史配置文件数量
    max_historical_profiles := vp_max_history

    if not na(vp_last_bar_idx_profile_start)
        // Determine the lookback period for the current profile
        lookback_bars = bar_index - vp_last_bar_idx_profile_start > 0 ? bar_index - vp_last_bar_idx_profile_start : 1

        // Determine high and low for the current profile period
        profile_high_price = ta.highest(high[1], lookback_bars) // Use high[1] to avoid current bar's forming high
        profile_low_price = ta.lowest(low[1], lookback_bars)   // Use low[1] to avoid current bar's forming low

        // Recalculate profile on new period or on the last bar
        is_new_vp_period = timeframe.change(vp_profile_tf)
        if is_new_vp_period or barstate.islast
            // 优化后的数据结构初始化
            vp_volume_values := array.new_float(vp_rows, 0.0) // 保留成交量数组初始化

            if vp_rows > 0
                // 预分配内存
                vp_y_coords := array.new_float(vp_rows)
                vp_x_coords := array.new_int(vp_rows)
                
                // 替换原有价格坐标计算
                float price_step = (profile_high_price - profile_low_price) / math.max(1, vp_rows - 1)
                for i = 0 to vp_rows - 1
                    array.set(vp_y_coords, i, profile_low_price + i * price_step)
                // 确保最后一个价格准确
                if vp_rows > 1
                    array.set(vp_y_coords, vp_rows - 1, profile_high_price)
                
                // 批量设置时间坐标
                for i = 0 to vp_rows - 1
                    array.set(vp_x_coords, i, vp_last_time_profile_start)

            // Aggregate volume from lower timeframe data
            float _price_step = (vp_rows > 1 and profile_high_price > profile_low_price) ? (profile_high_price - profile_low_price) / (vp_rows - 1) : 0.0
            float inv_price_step = _price_step != 0 ? 1 / _price_step : 0

            int end_bar_offset = barstate.islast ? 0 : 1
            // 优化成交量分配循环
            for i = lookback_bars - end_bar_offset to 0
                vol_at_bar_arr = ltf_V_arr[i] 
                high_at_bar_arr = ltf_H_arr[i]
                low_at_bar_arr = ltf_L_arr[i]

                if array.size(vol_at_bar_arr) > 0
                    int size_vol = array.size(vol_at_bar_arr)
                    for k = 0 to size_vol - 1
                        float ltf_bar_vol = array.get(vol_at_bar_arr, k)
                        if ltf_bar_vol <= 0
                            continue
                            
                        // 先获取当前小周期的高低
                        float ltf_bar_high = array.get(high_at_bar_arr, k)
                        float ltf_bar_low = array.get(low_at_bar_arr, k)
                        
                        // 处理单行情况（profile高度为0）
                        if profile_high_price == profile_low_price
                            if ltf_bar_low <= profile_low_price and ltf_bar_high >= profile_low_price
                                array.set(vp_volume_values, 0, array.get(vp_volume_values, 0) + ltf_bar_vol)
                            continue
                            
                        // 使用整数运算计算行索引（优化浮点运算）
                        float low_offset = (ltf_bar_low - profile_low_price) * inv_price_step
                        float high_offset = (ltf_bar_high - profile_low_price) * inv_price_step
                        int start_row_idx = int(math.max(0, low_offset))
                        int end_row_idx = int(math.min(vp_rows - 1, high_offset))
                        
                        // 快速检查是否需要处理
                        if start_row_idx > vp_rows - 1 or end_row_idx < 0
                            continue
                            
                        // 确保有效范围
                        start_row_idx := math.max(0, start_row_idx)
                        end_row_idx := math.min(vp_rows - 1, end_row_idx)
                        
                        if start_row_idx <= end_row_idx
                            int num_rows_spanned = end_row_idx - start_row_idx + 1
                            float vol_per_spanned_row = ltf_bar_vol / num_rows_spanned
                            
                            // 直接累加成交量
                            for j = start_row_idx to end_row_idx
                                array.set(vp_volume_values, j, array.get(vp_volume_values, j) + vol_per_spanned_row)


            // Find VPOC (price level with max volume)
            // Ensure vp_volume_values is not empty before calling array.max, though it's initialized with vp_rows elements.
            max_volume_for_poc = array.size(vp_volume_values) > 0 ? array.max(vp_volume_values) : 0.0
            poc_price = array.get(vp_y_coords, array.indexof(vp_volume_values, max_volume_for_poc))

            // 优化后的Value Area计算算法
            vp_value_area_low_idx := na
            vp_value_area_high_idx := na

            // 预先计算总成交量
            float total_volume = 0.0
            for i = 0 to array.size(vp_volume_values) - 1
                total_volume += array.get(vp_volume_values, i)

            // 优化扩展算法
            if total_volume > 0
                int poc_index = array.indexof(vp_volume_values, max_volume_for_poc)
                float target_volume = total_volume * 0.7
                float current_volume = array.get(vp_volume_values, poc_index)
                
                vp_value_area_low_idx := poc_index
                vp_value_area_high_idx := poc_index
                
                int l_ptr = poc_index - 1
                int r_ptr = poc_index + 1
                int loop_count = 0
                int max_loops = vp_rows * 2  // 防止无限循环
                
                while current_volume < target_volume and loop_count < max_loops
                    loop_count += 1
                    float vol_left = l_ptr >= 0 ? array.get(vp_volume_values, l_ptr) : -1
                    float vol_right = r_ptr < vp_rows ? array.get(vp_volume_values, r_ptr) : -1
                    
                    if vol_left > vol_right
                        current_volume += vol_left
                        vp_value_area_low_idx := l_ptr
                        l_ptr -= 1
                    else
                        current_volume += vol_right
                        vp_value_area_high_idx := r_ptr
                        r_ptr += 1
            
            // Prepare polyline points
            // Scaling factor for profile width
            max_aggregated_volume = array.max(vp_volume_values) > 0 ? array.max(vp_volume_values) : 1
            time_width_for_profile = 0.0 // Initialize to float for calculations
            
            base_time_width = float(time[0] - vp_last_time_profile_start) // Ensure float for calculation

            if vp_extend_profile_percent == 0
                // If extend percent is 0, use the base time width, ensuring it's at least 1
                time_width_for_profile := base_time_width > 0 ? base_time_width : 1.0
            else
                // Calculate width based on extend percentage
                calculated_width = base_time_width * (vp_extend_profile_percent / 100.0)
                // Ensure the calculated width is at least 1
                time_width_for_profile := calculated_width > 0 ? calculated_width : 1.0
            
            // Final defensive check to ensure time_width_for_profile is positive, at least 1.0
            time_width_for_profile := time_width_for_profile > 0 ? time_width_for_profile : 1.0

            scaling_factor = max_aggregated_volume / time_width_for_profile
            scaling_factor := scaling_factor > 0 ? scaling_factor : 1 // Avoid division by zero or negative scaling

            for j = 0 to array.size(vp_volume_values) - 1
                scaled_volume_as_time_offset = math.floor(array.get(vp_volume_values, j) / scaling_factor)
                array.set(vp_x_coords, j, vp_last_time_profile_start + scaled_volume_as_time_offset)

            // Build points for polyline
            array.clear(vp_profile_points_array)
            array.push(vp_profile_points_array, chart.point.from_time(vp_last_time_profile_start, profile_low_price))
            for i = 0 to array.size(vp_x_coords) - 1
                array.push(vp_profile_points_array, chart.point.from_time(array.get(vp_x_coords, i), array.get(vp_y_coords, i)))
            array.push(vp_profile_points_array, chart.point.from_time(vp_last_time_profile_start, profile_high_price))
            
            // 构建Value Area的点阵列
            array.clear(vp_value_area_points_array)
            if not na(vp_value_area_low_idx) and not na(vp_value_area_high_idx) and vp_value_area_low_idx >= 0 and vp_value_area_high_idx >= 0 and vp_value_area_low_idx < array.size(vp_y_coords) and vp_value_area_high_idx < array.size(vp_y_coords)
                // 添加Value Area下边界点
                value_area_low_price = array.get(vp_y_coords, vp_value_area_low_idx)
                value_area_high_price = array.get(vp_y_coords, vp_value_area_high_idx)
                
                array.push(vp_value_area_points_array, chart.point.from_time(vp_last_time_profile_start, value_area_low_price))
                
                // 添加Value Area右侧边界点
                for i = vp_value_area_low_idx to vp_value_area_high_idx
                    if i >= 0 and i < array.size(vp_x_coords) and i < array.size(vp_y_coords)
                        array.push(vp_value_area_points_array, chart.point.from_time(array.get(vp_x_coords, i), array.get(vp_y_coords, i)))
                
                // 添加Value Area上边界点
                array.push(vp_value_area_points_array, chart.point.from_time(vp_last_time_profile_start, value_area_high_price))

            // Delete old polyline and draw new one
            if not na(vp_current_profile_polyline)
                vp_current_profile_polyline.delete()
                vp_current_profile_polyline := na
                
            if not na(vp_current_value_area_polyline)
                vp_current_value_area_polyline.delete()
                vp_current_value_area_polyline := na

            if vp_show_profile
                vp_current_profile_polyline := polyline.new(vp_profile_points_array, curved = false, closed = true, 
                                   line_color = vp_profile_color, fill_color = vp_profile_color, 
                                   xloc = xloc.bar_time)
                                   
                // 如果显示VP，同时显示Value Area
                if array.size(vp_value_area_points_array) > 2
                    vp_current_value_area_polyline := polyline.new(vp_value_area_points_array, curved = false, closed = true, 
                                       line_color = vp_value_area_color, fill_color = vp_value_area_color, 
                                       xloc = xloc.bar_time)

            // Handle VPOC lines and labels
            if is_new_vp_period
                // 添加当前的VP图形到历史数组中
                if vp_show_historical and not na(vp_current_profile_polyline) // profile_low_price and profile_high_price would have been calculated for the period
                    // 创建一个新的点数组用于历史VP
                    var array<chart.point> historical_points = array.new<chart.point>()
                    array.clear(historical_points)
                    
                    // 添加底部点
                    array.push(historical_points, chart.point.from_time(vp_last_time_profile_start, profile_low_price))
                    
                    // 添加右侧点
                    for i = 0 to array.size(vp_x_coords) - 1
                        if not na(array.get(vp_x_coords, i)) and not na(array.get(vp_y_coords, i))
                            array.push(historical_points, chart.point.from_time(array.get(vp_x_coords, i), array.get(vp_y_coords, i)))
                    
                    // 添加顶部点
                    array.push(historical_points, chart.point.from_time(vp_last_time_profile_start, profile_high_price))
                    
                    // 创建历史VP图形
                    if array.size(historical_points) > 2
                        historical_profile = polyline.new(historical_points, curved = false, closed = true, 
                                               line_color = vp_historical_color, fill_color = vp_historical_color, 
                                               xloc = xloc.bar_time)
                        array.unshift(vp_historical_profiles, historical_profile)
                        
                        // 限制历史VP数量
                        if array.size(vp_historical_profiles) > max_historical_profiles
                            old_profile = array.pop(vp_historical_profiles)
                            polyline.delete(old_profile)
                            
                    // 如果有Value Area数据，也保存为历史Value Area
                    if not na(vp_value_area_low_idx) and not na(vp_value_area_high_idx) and array.size(vp_value_area_points_array) > 2
                        var array<chart.point> historical_va_points = array.new<chart.point>()
                        array.clear(historical_va_points)
                        
                        // 复制当前的Value Area点到历史Value Area
                        for i = 0 to array.size(vp_value_area_points_array) - 1
                            array.push(historical_va_points, array.get(vp_value_area_points_array, i))
                        
                        if array.size(historical_va_points) > 2
                            historical_va = polyline.new(historical_va_points, curved = false, closed = true, 
                                              line_color = vp_value_area_color, fill_color = vp_value_area_color, 
                                              xloc = xloc.bar_time)
                            array.unshift(vp_historical_value_areas, historical_va)
                            
                            // 限制历史Value Area数量
                            if array.size(vp_historical_value_areas) > max_historical_profiles
                                old_va = array.pop(vp_historical_value_areas)
                                polyline.delete(old_va)

                // 保存当前周期的高低价格，用于下一周期创建历史VP
                vp_last_profile_low := profile_low_price
                vp_last_profile_high := profile_high_price

                // 存储历史VPOC
                if vp_show_poc and not na(poc_price)
                    array.unshift(vp_historical_pocs, line.new(vp_last_time_profile_start, poc_price, time, poc_price, 
                                      xloc = xloc.bar_time, color = vp_poc_color, width = 1, style=DEFAULT_LINE_STYLE))
                    // 限制历史VPOC数量
                    if array.size(vp_historical_pocs) > max_historical_profiles * 3
                        line.delete(array.pop(vp_historical_pocs))

                // Clean up current VPOC drawings from previous period (if any) using pool
                if not na(vp_current_poc_main_line)
                    return_line_to_pool(vp_current_poc_main_line)
                    vp_current_poc_main_line := na
                if not na(vp_current_poc_label_line)
                    return_line_to_pool(vp_current_poc_label_line)
                    vp_current_poc_label_line := na
                if not na(vp_current_poc_label)
                    return_label_to_pool(vp_current_poc_label)
                    vp_current_poc_label := na
            
            else if barstate.islast and vp_show_poc // Update current VPOC line and label on last bar
                if na(vp_current_poc_main_line) // First time drawing on last bar or after reset
                    vp_current_poc_main_line := get_line_from_pool()
                    vp_current_poc_label_line := get_line_from_pool()
                    vp_current_poc_label := get_label_from_pool()

                // Update main POC line (from profile start to current bar)
                vp_current_poc_main_line.set_xy1(vp_last_time_profile_start, poc_price)
                vp_current_poc_main_line.set_xy2(time, poc_price)
                vp_current_poc_main_line.set_color(vp_poc_color)
                vp_current_poc_main_line.set_width(1)
                vp_current_poc_main_line.set_style(DEFAULT_LINE_STYLE)
                
                // Update POC label line (short segment at current bar)
                vp_current_poc_label_line.set_xy1(bar_index, poc_price)
                vp_current_poc_label_line.set_xy2(bar_index + vp_label_offset_bars, poc_price)
                vp_current_poc_label_line.set_color(vp_poc_color)
                vp_current_poc_label_line.set_width(1)
                vp_current_poc_label_line.set_style(DEFAULT_LINE_STYLE)
                //vp_current_poc_label_line.set_xloc(xloc.bar_index)

                // Update POC label
                vp_current_poc_label.set_xy(bar_index + vp_label_offset_bars, poc_price)
                vp_current_poc_label.set_text("POC")
                vp_current_poc_label.set_tooltip(str.tostring(poc_price, vp_price_format))
                vp_current_poc_label.set_color(color.new(vp_poc_color, 80)) // Semi-transparent background
                vp_current_poc_label.set_textcolor(color.white) // Contrasting text
                vp_current_poc_label.set_style(label.style_label_left)
                //vp_current_poc_label.set_xloc(xloc.bar_index)

// Update Volume Profile anchor points
if vp_enable
    if timeframe.change(vp_profile_tf) or na(vp_last_bar_idx_profile_start) // Also initialize on first run
        vp_last_bar_idx_profile_start := bar_index
        vp_last_time_profile_start := time

        // When profile TF changes, clear the current POC line/label from the previous profile period
        if not na(vp_current_poc_main_line)
            return_line_to_pool(vp_current_poc_main_line)
            vp_current_poc_main_line := na
        if not na(vp_current_poc_label_line)
            return_line_to_pool(vp_current_poc_label_line)
            vp_current_poc_label_line := na
        if not na(vp_current_poc_label)
            return_label_to_pool(vp_current_poc_label)
            vp_current_poc_label := na
            
        // 同时清理Value Area对象
        if not na(vp_current_value_area_polyline)
            vp_current_value_area_polyline.delete()
            vp_current_value_area_polyline := na
            
        // 重置Value Area索引
        vp_value_area_low_idx := na
        vp_value_area_high_idx := na
        
        // 清空Value Area点阵列
        array.clear(vp_value_area_points_array)


// =============================================================================
// ==== PLOTTING ====
// =============================================================================

plot(show_7d ? rvwap_7d : na, title='7D RVWAP', color=color_7d, linewidth=1)
plot(show_30d ? rvwap_30d : na, title='30D RVWAP', color=color_30d, linewidth=1)
plot(show_90d ? rvwap_90d : na, title='90D RVWAP', color=color_90d, linewidth=1)
plot(show_365d ? rvwap_365d : na, title='365D RVWAP', color=color_365d, linewidth=1)

vwap_plot1 = plot(VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? vwap1 : na, title='VWAP 1', color=VWAP1_Col, linewidth=1)
lowerBand_1 = plot(VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? band1_lower : na, title='L Band 1', color=Bands1_Col, linewidth=1)
upperBand_1 = plot(VWAP1_Ctl and (Anchor1 != 'Quarter' or not is_monthly_or_higher_tf) ? band1_upper : na, title='U Band 1', color=Bands1_Col, linewidth=1)
fill(upperBand_1, lowerBand_1, color=VWAP1_Bgc, title='Fill 1')

vwap_plot2 = plot(VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? vwap2 : na, title='VWAP 2', color=VWAP2_Col, linewidth=1)
lowerBand_2 = plot(VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? band2_lower : na, title='L Band 2', color=Bands2_Col, linewidth=1)
upperBand_2 = plot(VWAP2_Ctl and (Anchor2 != 'Month' or not is_weekly_or_higher_tf) ? band2_upper : na, title='U Band 2', color=Bands2_Col, linewidth=1)
fill(upperBand_2, lowerBand_2, color=VWAP2_Bgc, title='Fill 2')

vwap_plot3 = plot(VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? vwap3 : na, title='VWAP 3', color=VWAP3_Col, linewidth=1)
lowerBand_3 = plot(VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? band3_lower : na, title='L Band 3', color=Bands3_Col, linewidth=1)
upperBand_3 = plot(VWAP3_Ctl and (Anchor3 != 'Week' or not is_12h_or_higher_tf) ? band3_upper : na, title='U Band 3', color=Bands3_Col, linewidth=1)
fill(upperBand_3, lowerBand_3, color=VWAP3_Bgc, title='Fill 3')

vwap_plot4 = plot(VWAP4_Ctl and not is_4h_or_higher_tf ? vwap4 : na, title='VWAP 4', color=VWAP4_Col, linewidth=1)
lowerBand_4 = plot(VWAP4_Ctl and not is_4h_or_higher_tf ? band4_lower : na, title='L Band 4', color=Bands4_Col, linewidth=1)
upperBand_4 = plot(VWAP4_Ctl and not is_4h_or_higher_tf ? band4_upper : na, title='U Band 4', color=Bands4_Col, linewidth=1)
fill(upperBand_4, lowerBand_4, color=VWAP4_Bgc, title='Fill 4')

vwap_plot5 = plot(VWAP5_Ctl ? vwap5 : na, title='VWAP 5', color=VWAP5_Col, linewidth=1)
lowerBand_5 = plot(VWAP5_Ctl ? band5_lower : na, title='L Band 5', color=Bands5_Col, linewidth=1)
upperBand_5 = plot(VWAP5_Ctl ? band5_upper : na, title='U Band 5', color=Bands5_Col, linewidth=1)
fill(upperBand_5, lowerBand_5, color=VWAP5_Bgc, title='Fill 5')


if barstate.islast 
    bool force_clean_labels = true 
    bool labels_need_update_flag = false
    
    if na(cache_yearlyOpen) or na(cache_monthlyOpen) or na(cache_weeklyOpen) or na(cache_quarterlyOpen) or na(cache_dailyOpen) or na(cache_lastWeeklyPOC) or na(cache_lastMonthlyPOC) or na(cache_lastQuarterlyPOC) or na(cache_lastYearlyPOC) or yearlyOpen != cache_yearlyOpen or monthlyOpen != cache_monthlyOpen or weeklyOpen != cache_weeklyOpen or quarterlyOpen != cache_quarterlyOpen or dailyOpen != cache_dailyOpen or lastWeeklyPOC != cache_lastWeeklyPOC or lastMonthlyPOC != cache_lastMonthlyPOC or lastQuarterlyPOC != cache_lastQuarterlyPOC or lastYearlyPOC != cache_lastYearlyPOC
        labels_need_update_flag := true
    
    if labels_need_update_flag or force_clean_labels
        if array.size(key_open_labels) > 0 
            for i = 0 to array.size(key_open_labels) - 1
                label lbl_to_return = array.get(key_open_labels, i)
                return_label_to_pool(lbl_to_return)
            array.clear(key_open_labels) 
        if array.size(key_open_lines) > 0
            for i = 0 to array.size(key_open_lines) - 1
                line line_to_return = array.get(key_open_lines, i)
                return_line_to_pool(line_to_return)
            array.clear(key_open_lines) 
            
        if array.size(pvwap_labels) > 0
            for i = 0 to array.size(pvwap_labels) - 1
                label lbl_to_return = array.get(pvwap_labels, i)
                return_label_to_pool(lbl_to_return)
            array.clear(pvwap_labels) 
        if array.size(pvwap_lines) > 0
            for i = 0 to array.size(pvwap_lines) - 1
                line line_to_return = array.get(pvwap_lines, i)
                return_line_to_pool(line_to_return)
            array.clear(pvwap_lines) 
        
        if show_pvwap_yearly and not na(lastYearlyPOC) and not na(thisYearStart)
            plot_previous_vwap_levels('Year', lastYearlyUpper, lastYearlyLower, lastYearlyPOC, thisYearStart, color_pvwap_yearly)
        if show_pvwap_quarterly and not na(lastQuarterlyPOC) and not na(thisQuarterStart) and not is_monthly_or_higher_tf
            plot_previous_vwap_levels('Quarter', lastQuarterlyUpper, lastQuarterlyLower, lastQuarterlyPOC, thisQuarterStart, color_pvwap_quarterly)
        if show_pvwap_monthly and not na(lastMonthlyPOC) and not na(thisMonthStart) and not is_weekly_or_higher_tf
            plot_previous_vwap_levels('Month', lastMonthlyUpper, lastMonthlyLower, lastMonthlyPOC, thisMonthStart, color_pvwap_monthly)
        if show_pvwap_weekly and not na(lastWeeklyPOC) and not na(thisWeekStart) and not is_12h_or_higher_tf
            plot_previous_vwap_levels('Week', lastWeeklyUpper, lastWeeklyLower, lastWeeklyPOC, thisWeekStart, color_pvwap_weekly)
        
        if not use_tf_consistent_pvwap 
            if VWAP1_Ctl and Anchor1 == 'Quarter' and not is_monthly_or_higher_tf
                plot_previous_vwap_levels(Anchor1, lastQuarterlyUpper, lastQuarterlyLower, lastQuarterlyPOC, thisQuarterStart, VWAP1_Col)
            if VWAP2_Ctl and Anchor2 == 'Month' and not is_weekly_or_higher_tf
                plot_previous_vwap_levels(Anchor2, lastMonthlyUpper, lastMonthlyLower, lastMonthlyPOC, thisMonthStart, VWAP2_Col)
            if VWAP3_Ctl and Anchor3 == 'Week' and not is_12h_or_higher_tf
                plot_previous_vwap_levels(Anchor3, lastWeeklyUpper, lastWeeklyLower, lastWeeklyPOC, thisWeekStart, VWAP3_Col)
            if VWAP5_Ctl and Anchor5 == 'Year'
                plot_previous_vwap_levels(Anchor5, lastYearlyUpper, lastYearlyLower, lastYearlyPOC, thisYearStart, VWAP5_Col)

        if show_MonthlyOpen
            plot_key_open_level(monthlyOpen, "MO", color_MonthlyOpen, keylevel_offset, keylevel_format)
        if show_YearlyOpen
            plot_key_open_level(yearlyOpen, "YO", color_YearlyOpen, keylevel_offset, keylevel_format)
        if show_WeeklyOpen
            plot_key_open_level(weeklyOpen, "WO", color_WeeklyOpen, keylevel_offset, keylevel_format)
        if show_QuarterlyOpen
            plot_key_open_level(quarterlyOpen, "QO", color_QuarterlyOpen, keylevel_offset, keylevel_format)
        if show_DailyOpen
            plot_key_open_level(dailyOpen, "DO", color_DailyOpen, keylevel_offset, keylevel_format)
            
        cache_yearlyOpen := yearlyOpen
        cache_monthlyOpen := monthlyOpen
        cache_weeklyOpen := weeklyOpen
        cache_quarterlyOpen := quarterlyOpen
        cache_dailyOpen := dailyOpen
        cache_lastWeeklyPOC := lastWeeklyPOC
        cache_lastMonthlyPOC := lastMonthlyPOC
        cache_lastQuarterlyPOC := lastQuarterlyPOC
        cache_lastYearlyPOC := lastYearlyPOC

// ---- Plot Monday Range Lines ----
var line prevMonHighLine = na
var line prevMonLowLine = na
var bool prevMondayLinesDrawn = false // State for previous Monday lines

var line currMonHighLine = na
var line currMonLowLine = na
var float lastPlottedMondayHigh = na // Store last plotted value
var float lastPlottedMondayLow = na  // Store last plotted value
var int lastPlottedMondayStartTime = na // Store last plotted start time
var bool currentMondayLinesActive = false // State for current Monday lines

// Manage Previous Monday lines
if isNewWeek or (prevMondayLinesDrawn and not show_MondayRange)
    if not na(prevMonHighLine)
        return_line_to_pool(prevMonHighLine)
        prevMonHighLine := na
    if not na(prevMonLowLine)
        return_line_to_pool(prevMonLowLine)
        prevMonLowLine := na
    prevMondayLinesDrawn := false

if show_MondayRange and isNewWeek and not na(prevMondayHigh) and not na(prevMondayStartBar) and not na(prevWeekEndBar)
    int safe_prev_monday_start = na
    if not na(prevMondayStartBar) and bar_index - prevMondayStartBar >= 0
        safe_prev_monday_start := math.min(4900, math.max(0, bar_index - prevMondayStartBar))
    
    int safe_prev_week_end = na
    if not na(prevWeekEndBar) and bar_index - prevWeekEndBar >= 0
        safe_prev_week_end := math.min(4900, math.max(0, bar_index - prevWeekEndBar))
    
    if not na(safe_prev_monday_start) and not na(safe_prev_week_end)
        prevMondayStartTime := time[safe_prev_monday_start]
        prevWeekEndTime := time[safe_prev_week_end]
    
        if not na(prevMondayStartTime) and not na(prevWeekEndTime)
            prevMonHighLine := get_line_from_pool()
            prevMonHighLine.set_xy1(x=prevMondayStartTime, y=prevMondayHigh)
            prevMonHighLine.set_xy2(x=prevWeekEndTime, y=prevMondayHigh)
            prevMonHighLine.set_color(color=color_PrevMonday)
            prevMonHighLine.set_width(width=1)
            prevMonHighLine.set_style(style=line.style_dotted)
            
            prevMonLowLine := get_line_from_pool()
            prevMonLowLine.set_xy1(x=prevMondayStartTime, y=prevMondayLow)
            prevMonLowLine.set_xy2(x=prevWeekEndTime, y=prevMondayLow)
            prevMonLowLine.set_color(color=color_PrevMonday)
            prevMonLowLine.set_width(width=1)
            prevMonLowLine.set_style(style=line.style_dotted)
            prevMondayLinesDrawn := true

// Manage Current Monday lines
if isNewWeek and currentMondayLinesActive // Cleanup at the start of a new week
    if not na(currMonHighLine)
        return_line_to_pool(currMonHighLine)
        currMonHighLine := na
    if not na(currMonLowLine)
        return_line_to_pool(currMonLowLine)
        currMonLowLine := na
    lastPlottedMondayHigh := na
    lastPlottedMondayLow := na
    lastPlottedMondayStartTime := na
    currentMondayLinesActive := false

if barstate.islast
    if show_MondayRange and not na(mondayHigh) and not na(mondayLow) and not na(mondayStartBar)
        int mondayStartTimeValue = na
        int safe_monday_start_idx = na
        if bar_index - mondayStartBar >= 0
            safe_monday_start_idx := math.min(4900, math.max(0, bar_index - mondayStartBar))
            mondayStartTimeValue := time[safe_monday_start_idx]

        if not na(mondayStartTimeValue)
            if not currentMondayLinesActive // Create lines
                currMonHighLine := get_line_from_pool()
                currMonLowLine := get_line_from_pool()
                
                currMonHighLine.set_xy1(x=mondayStartTimeValue, y=mondayHigh)
                currMonHighLine.set_xy2(x=time, y=mondayHigh)
                currMonHighLine.set_color(color=color_CurrMonday)
                currMonHighLine.set_width(width=1)
                currMonHighLine.set_style(style=line.style_dotted)
                
                currMonLowLine.set_xy1(x=mondayStartTimeValue, y=mondayLow)
                currMonLowLine.set_xy2(x=time, y=mondayLow)
                currMonLowLine.set_color(color=color_CurrMonday)
                currMonLowLine.set_width(width=1)
                currMonLowLine.set_style(style=line.style_dotted)
                
                lastPlottedMondayHigh := mondayHigh
                lastPlottedMondayLow := mondayLow
                lastPlottedMondayStartTime := mondayStartTimeValue
                currentMondayLinesActive := true
            else // Lines exist, update them
                bool needsYUpdate = lastPlottedMondayHigh != mondayHigh or lastPlottedMondayLow != mondayLow
                bool needsX1Update = lastPlottedMondayStartTime != mondayStartTimeValue
                
                if needsX1Update
                    currMonHighLine.set_x1(x=mondayStartTimeValue)
                    currMonLowLine.set_x1(x=mondayStartTimeValue)
                    lastPlottedMondayStartTime := mondayStartTimeValue
                
                if needsYUpdate
                    currMonHighLine.set_y1(y=mondayHigh)
                    currMonHighLine.set_y2(y=mondayHigh)
                    currMonLowLine.set_y1(y=mondayLow)
                    currMonLowLine.set_y2(y=mondayLow)
                    lastPlottedMondayHigh := mondayHigh
                    lastPlottedMondayLow := mondayLow
                
                currMonHighLine.set_x2(x=time)
                currMonLowLine.set_x2(x=time)

    else if currentMondayLinesActive // show_MondayRange is false or not Monday anymore
        if not na(currMonHighLine)
            return_line_to_pool(currMonHighLine)
            currMonHighLine := na
        if not na(currMonLowLine)
            return_line_to_pool(currMonLowLine)
            currMonLowLine := na
        lastPlottedMondayHigh := na
        lastPlottedMondayLow := na
        lastPlottedMondayStartTime := na
        currentMondayLinesActive := false

// ==== Market Order Bubble Plotting ====
// 绘制买单气泡（不同大小）
plotshape(plot_buy_bubble_tiny, title="Buy Bubble Tiny", style=shape.circle, location=location.abovebar, color=buy_color, size=size.tiny)
plotshape(plot_buy_bubble_small, title="Buy Bubble Small", style=shape.circle, location=location.abovebar, color=buy_color, size=size.small)
plotshape(plot_buy_bubble_normal, title="Buy Bubble Normal", style=shape.circle, location=location.abovebar, color=buy_color, size=size.normal)
plotshape(plot_buy_bubble_large, title="Buy Bubble Large", style=shape.circle, location=location.abovebar, color=buy_color, size=size.large)
plotshape(plot_buy_bubble_huge, title="Buy Bubble Huge", style=shape.circle, location=location.abovebar, color=buy_color, size=size.huge)

// 绘制卖单气泡（不同大小）
plotshape(plot_sell_bubble_tiny, title="Sell Bubble Tiny", style=shape.circle, location=location.belowbar, color=sell_color, size=size.tiny)
plotshape(plot_sell_bubble_small, title="Sell Bubble Small", style=shape.circle, location=location.belowbar, color=sell_color, size=size.small)
plotshape(plot_sell_bubble_normal, title="Sell Bubble Normal", style=shape.circle, location=location.belowbar, color=sell_color, size=size.normal)
plotshape(plot_sell_bubble_large, title="Sell Bubble Large", style=shape.circle, location=location.belowbar, color=sell_color, size=size.large)
plotshape(plot_sell_bubble_huge, title="Sell Bubble Huge", style=shape.circle, location=location.belowbar, color=sell_color, size=size.huge)

// 如果需要显示文本，使用label
if mob_show_text and enable_mob
    // 买单标签
    if is_large_buy
        buy_label_text = str.tostring(math.round(buy_ratio, 1)) + "x"
        label.new(x=bar_index, y=high + (high - low) * 0.15, 
                 text=buy_label_text, 
                 style=label.style_label_down, 
                 color=color.new(color.green, buy_transp), 
                 textcolor=color.white, 
                 size=size.small)
    
    // 卖单标签
    if is_large_sell
        sell_label_text = str.tostring(math.round(sell_ratio, 1)) + "x"
        label.new(x=bar_index, y=low - (high - low) * 0.15, 
                 text=sell_label_text, 
                 style=label.style_label_up, 
                 color=color.new(color.red, sell_transp), 
                 textcolor=color.white, 
                 size=size.small)

// END OF SCRIPT
